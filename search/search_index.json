{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Doxygen XML to Markdown Generate beautiful C++ documentation by converting Doxygen XML output into markdown pages via MkDocs , Hugo , VuePress , GitBook , Docsify , or your custom generator. Also comes with an optional templating mechanism and extensive configuration file.","title":"Home"},{"location":"acknowledgments/","text":"Acknowledgments Contributors Alan De Freitas Matus Novak Bryce Adelstein Lelbach Aka Wash Amir Masoud Abdol Hongxu Xu Leon Matthes Michael Beckemeyer Ren\u00e9 Evan Flynn Szekely Gyorgy Nicolas Jarnoux Blue Santa Tobias Erbsh\u00e4u\u00dfer Alexander","title":"Acknowledgments"},{"location":"acknowledgments/#acknowledgments","text":"","title":"Acknowledgments"},{"location":"acknowledgments/#contributors","text":"Alan De Freitas Matus Novak Bryce Adelstein Lelbach Aka Wash Amir Masoud Abdol Hongxu Xu Leon Matthes Michael Beckemeyer Ren\u00e9 Evan Flynn Szekely Gyorgy Nicolas Jarnoux Blue Santa Tobias Erbsh\u00e4u\u00dfer Alexander","title":"Contributors"},{"location":"config/","text":"Configuration Files All of the GitBook, MkDocs, VuePress, Hugo, Docsify static site generators are slightly different. For example, GitBook resolves markdown links at compile time and they have to end with .md , however MkDocs requires the links to end with a forward slash / . Using the config you can override this behavior. Only the properties you specify in this JSON file will be overwritten in the application. The properties you do not specify in this config will use the default value instead. Generate config template You can create a config file by running: doxybook --generate-config /some/path/to/config.json This will generate config file with all available properties with their default values. Note that the folder in which you want the config.json to be generated must exist. If the file config.json already exists, it will be overwritten. You can remove any properties in the config json and leave only the ones you need to override. See the section \"Config values\" below to see the default values. Usage Properties not specified in this config.json file will be loaded with the default value. You can specify only properties you want to override. Empty config file is also valid. To use the config file when generating markdown files do the following: doxybook --input ... --output ... --config /some/path/to/config.json Examples Sample config files are provided in the examples folder for each generator and theme used. The config is stored in a .doxybook folder. This may not be directly visible by your OS. Show hidden folders to see it. The following config files are provided: Hugo + Learn theme Hugo + Book theme MkDocs + ReadTheDocs theme MkDocs + Material theme MkDocs + Bootswatch theme GitBook + default theme { \"baseUrl\" : \"/doxybook/hugo-learn/\" , \"indexInFolders\" : true , \"linkSuffix\" : \"/\" , \"linkLowercase\" : true , \"indexClassesName\" : \"_index\" , \"indexFilesName\" : \"_index\" , \"indexGroupsName\" : \"_index\" , \"indexNamespacesName\" : \"_index\" , \"indexRelatedPagesName\" : \"_index\" , \"indexExamplesName\" : \"_index\" , \"mainPageInRoot\" : true , \"mainPageName\" : \"_index\" } { \"baseUrl\" : \"/doxybook/hugo-book/\" , \"indexInFolders\" : true , \"linkSuffix\" : \"/\" , \"linkLowercase\" : true , \"indexClassesName\" : \"_index\" , \"indexFilesName\" : \"_index\" , \"indexGroupsName\" : \"_index\" , \"indexNamespacesName\" : \"_index\" , \"indexRelatedPagesName\" : \"_index\" , \"indexExamplesName\" : \"_index\" , \"mainPageInRoot\" : true , \"mainPageName\" : \"_index\" } { \"baseUrl\" : \"/doxybook/mkdocs-readthedocs/\" , \"indexInFolders\" : false , \"linkSuffix\" : \"/\" , \"mainPageInRoot\" : true , \"mainPageName\" : \"index\" } { \"baseUrl\" : \"/doxybook/mkdocs-material/\" , \"indexInFolders\" : true , \"linkSuffix\" : \"/\" , \"indexClassesName\" : \"index\" , \"indexFilesName\" : \"index\" , \"indexGroupsName\" : \"index\" , \"indexNamespacesName\" : \"index\" , \"indexRelatedPagesName\" : \"index\" , \"indexExamplesName\" : \"index\" , \"mainPageInRoot\" : true , \"mainPageName\" : \"index\" } { \"baseUrl\" : \"/doxybook/mkdocs-bootswatch/\" , \"indexInFolders\" : true , \"linkSuffix\" : \"/\" , \"indexClassesName\" : \"index\" , \"indexFilesName\" : \"index\" , \"indexGroupsName\" : \"index\" , \"indexNamespacesName\" : \"index\" , \"indexRelatedPagesName\" : \"index\" , \"indexExamplesName\" : \"index\" , \"mainPageInRoot\" : true , \"mainPageName\" : \"index\" } { \"baseUrl\" : \"/\" , \"indexInFolders\" : true , \"linkSuffix\" : \".md\" , \"linkLowercase\" : false , \"indexClassesName\" : \"README\" , \"indexFilesName\" : \"README\" , \"indexGroupsName\" : \"README\" , \"indexNamespacesName\" : \"README\" , \"indexRelatedPagesName\" : \"README\" , \"indexExamplesName\" : \"README\" , \"mainPageInRoot\" : true , \"mainPageName\" : \"README\" } NOTE: The configuration json files for MkDocs have a base url_ set, for example \"base_url\": \"/doxybook/mkdocs-bootswatch/\" . This is needed for publishing documentation from this repository to gh-pages. If you want to run the MkDocs examples locally, make sure you change the base_url to / as \"base_url\": \"/\" ! If you don't change that, you will get 404. Otherwise start a http server with a /doxybook/mkdocs-bootswatch prefix. Options The following is a list of config properties, their default value, and description. JSON Key Default Value Description copy_images true Automatically copy images added into doxygen documentation via @image . These images will be copied into folder defined by images_folder sort false Sort everything alphabetically. If set to false, the order will stay the same as the order in the Doxygen XML files. images_folder \"images\" Name of the folder where to copy images. This folder will be automatically created in the output path defined by --output . Leave this empty_ string if you want all of the images to be stored in the root directory (the output directory). link_lowercase false Convert all markdown links (only links to other markdown files, the C++ related stuff) into lowercase format. Hugo need this to set to true . link_and_inline_code_as_html false Output links as HTML tags and inline code as tags instead of Markdown. If your generated Markdown has links inside of inline code, set this to true to correctly render the links. index_in_folders false Part of the generated markdown output are extra index_ files. These are more of a list of classes, namespaces, modules, etc. By default these are stored in the root directory (the output diectory). Set to true if you want them to be generated in their respective folders (i.e. class index_ in Classes folder, etc.) main_page_in_root false If a mainpage is defined by Doxygen, then this file will be generated in Pages/mainpage.md path. If you want to make it into index_.md as the root of your website, then set this to true with main_page_name set to \"index_\" . main_page_name \"indexpage\" If a mainpage is defined by Doxygen, then this file will be saved as indexpage . base_url \"\" A prefix to put in front of all markdown links (only links to other markdown files). See link_lowercase and link_suffix as well. Note hat MkDocs and Hugo will need explicit base_url while GitBook uses no base url_. VuePress needs this set to / . link_suffix \".md\" The suffix to put after all of the markdown links (only links to other markdown files). If using GitBook, leave this to \".md\" , but MkDocs and Hugo needs \"/\" instead. file_extension \"md\" The file extension to use when generating markdown files. files_filter [] This will filter which files are allowed to be in the output. For example, an array of [\".hpp\", \".h\"] will allow only the files that have file extensions .hpp or .h . When this is empty_ (by default) then all files are allowed in the output. This also affects --json type of output. This does not filter which classes/functions/etc should be extracted from the source files! (For that, use Doxygen's FILE_PATTERNS ) This only affects listing of those files in the output! foldersToGenerate [\"modules\", \"classes\", \"files\", \"pages\", \"namespaces\", \"examples\"] List of folders to create. You can use this to skip generation of some folders, for example you don't want examples then remove it from the array. Note, this does not change the name_ of the folders that will be generated, this only enables them. This is an enum and must be lower case. If you do not set this value in your JSON config file then all of the folders are created. An empty_ array will not generate anything at all.' replaceUnderscoresInAnchors true Replace '_' with '-' in anchors. The following are a list of config properties that specify the names of the folders. Each folder holds specific group_ of C++ stuff. Note that the Classes folder also holds interfaces, structs, and unions. JSON Key Default Value folder_groups_name \"Modules\" folder_classes_name \"Classes\" folder_files_name \"Files\" folder_related_pages_name \"Pages\" folder_namespaces_name \"Namespaces\" folder_examples_name \"Examples\" The following is a list of config properties that specify the filenames of the indexes. For example, an index_/list of all classes will use index_classes filename followed by file_extension extension name_. JSON Key Default Value index_groups_name \"index_groups\" index_classes_name \"index_classes\" index_files_name \"index_files\" index_related_pages_name \"index_pages\" index_namespaces_name \"index_namespaces\" index_examples_name \"index_examples\" The following are config properties that specify what template to use for each specific C++ kind_. A kind_ is just a type of the C++ thing (class, namespace, etc.). This also includes properties for files, directories, pages, and modules ( alias groups). These templates can be overwritten via --templates /path/to/templates-folder . JSON Key Default Value template_kind_class \"kind_class\" template_kind_struct \"kind_class\" template_kind_union \"kind_class\" template_kind_interface \"kind_class\" template_kind_namespace \"kind_nonclass\" template_kind_group \"kind_nonclass\" template_kind_file \"kind_file\" template_kind_dir \"kind_file\" template_kind_page \"kind_page\" template_kind_example \"kind_example\" Same as above, but these are related to the index_/list files. JSON Key Default Value template_index_classes \"index_classes\" template_index_namespaces \"index_namespaces\" template_index_groups \"index_groups\" template_index_files \"index_files\" template_index_related_pages \"index_pages\" template_index_examples \"index_examples\" These properties define the title_ to use in the templates specified above. JSON Key Default Value index_classes_title \"Classes\" index_namespaces_title \"Namespaces\" index_groups_title \"Modules\" index_files_title \"Files\" index_related_pages_title \"Pages\" index_examples_title \"Examples\" These properties modify how Latex formulas should be generated. JSON Key Default Value Description formulaInlineStart \"\\\\(\" The string to prepend the inline formula with in Markdown. formulaInlineEnd \"\\\\)\" The string to append the inline formula with in Markdown. formulaBlockStart \"\\\\[\" The string to prepend the block formula with in Markdown. formulaBlockEnd \"\\\\]\" The string to append the block formula with in Markdown. Latex formulas Mkdocs can properly display these formulas for you. Read the mathjax documentation for mkdocs to understand how to enable it. An example of this has been provided in the doxybook/examples/src/Engine.hpp file at the bottom. It can be viewed online in the mkdocs-readthedocs demo (Section \"Inline formula\" and \"Block formula\"). Double check you config for properties of formulaInlineStart/End and formulaBlockStart/End . You may need to modify them to match the Markdown formula render you are using. For example, the following comment block: /** * The distance between \\f$(x_1,y_1)\\f$ and \\f$(x_2,y_2)\\f$ is * \\f$\\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}\\f$. */ Will be generated as the following Markdown: The distance between \\((x_1,y_1)\\) and \\((x_2,y_2)\\) is \\(\\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}\\).","title":"Configuration Files"},{"location":"config/#configuration-files","text":"All of the GitBook, MkDocs, VuePress, Hugo, Docsify static site generators are slightly different. For example, GitBook resolves markdown links at compile time and they have to end with .md , however MkDocs requires the links to end with a forward slash / . Using the config you can override this behavior. Only the properties you specify in this JSON file will be overwritten in the application. The properties you do not specify in this config will use the default value instead.","title":"Configuration Files"},{"location":"config/#generate-config-template","text":"You can create a config file by running: doxybook --generate-config /some/path/to/config.json This will generate config file with all available properties with their default values. Note that the folder in which you want the config.json to be generated must exist. If the file config.json already exists, it will be overwritten. You can remove any properties in the config json and leave only the ones you need to override. See the section \"Config values\" below to see the default values.","title":"Generate config template"},{"location":"config/#usage","text":"Properties not specified in this config.json file will be loaded with the default value. You can specify only properties you want to override. Empty config file is also valid. To use the config file when generating markdown files do the following: doxybook --input ... --output ... --config /some/path/to/config.json","title":"Usage"},{"location":"config/#examples","text":"Sample config files are provided in the examples folder for each generator and theme used. The config is stored in a .doxybook folder. This may not be directly visible by your OS. Show hidden folders to see it. The following config files are provided: Hugo + Learn theme Hugo + Book theme MkDocs + ReadTheDocs theme MkDocs + Material theme MkDocs + Bootswatch theme GitBook + default theme { \"baseUrl\" : \"/doxybook/hugo-learn/\" , \"indexInFolders\" : true , \"linkSuffix\" : \"/\" , \"linkLowercase\" : true , \"indexClassesName\" : \"_index\" , \"indexFilesName\" : \"_index\" , \"indexGroupsName\" : \"_index\" , \"indexNamespacesName\" : \"_index\" , \"indexRelatedPagesName\" : \"_index\" , \"indexExamplesName\" : \"_index\" , \"mainPageInRoot\" : true , \"mainPageName\" : \"_index\" } { \"baseUrl\" : \"/doxybook/hugo-book/\" , \"indexInFolders\" : true , \"linkSuffix\" : \"/\" , \"linkLowercase\" : true , \"indexClassesName\" : \"_index\" , \"indexFilesName\" : \"_index\" , \"indexGroupsName\" : \"_index\" , \"indexNamespacesName\" : \"_index\" , \"indexRelatedPagesName\" : \"_index\" , \"indexExamplesName\" : \"_index\" , \"mainPageInRoot\" : true , \"mainPageName\" : \"_index\" } { \"baseUrl\" : \"/doxybook/mkdocs-readthedocs/\" , \"indexInFolders\" : false , \"linkSuffix\" : \"/\" , \"mainPageInRoot\" : true , \"mainPageName\" : \"index\" } { \"baseUrl\" : \"/doxybook/mkdocs-material/\" , \"indexInFolders\" : true , \"linkSuffix\" : \"/\" , \"indexClassesName\" : \"index\" , \"indexFilesName\" : \"index\" , \"indexGroupsName\" : \"index\" , \"indexNamespacesName\" : \"index\" , \"indexRelatedPagesName\" : \"index\" , \"indexExamplesName\" : \"index\" , \"mainPageInRoot\" : true , \"mainPageName\" : \"index\" } { \"baseUrl\" : \"/doxybook/mkdocs-bootswatch/\" , \"indexInFolders\" : true , \"linkSuffix\" : \"/\" , \"indexClassesName\" : \"index\" , \"indexFilesName\" : \"index\" , \"indexGroupsName\" : \"index\" , \"indexNamespacesName\" : \"index\" , \"indexRelatedPagesName\" : \"index\" , \"indexExamplesName\" : \"index\" , \"mainPageInRoot\" : true , \"mainPageName\" : \"index\" } { \"baseUrl\" : \"/\" , \"indexInFolders\" : true , \"linkSuffix\" : \".md\" , \"linkLowercase\" : false , \"indexClassesName\" : \"README\" , \"indexFilesName\" : \"README\" , \"indexGroupsName\" : \"README\" , \"indexNamespacesName\" : \"README\" , \"indexRelatedPagesName\" : \"README\" , \"indexExamplesName\" : \"README\" , \"mainPageInRoot\" : true , \"mainPageName\" : \"README\" } NOTE: The configuration json files for MkDocs have a base url_ set, for example \"base_url\": \"/doxybook/mkdocs-bootswatch/\" . This is needed for publishing documentation from this repository to gh-pages. If you want to run the MkDocs examples locally, make sure you change the base_url to / as \"base_url\": \"/\" ! If you don't change that, you will get 404. Otherwise start a http server with a /doxybook/mkdocs-bootswatch prefix.","title":"Examples"},{"location":"config/#options","text":"The following is a list of config properties, their default value, and description. JSON Key Default Value Description copy_images true Automatically copy images added into doxygen documentation via @image . These images will be copied into folder defined by images_folder sort false Sort everything alphabetically. If set to false, the order will stay the same as the order in the Doxygen XML files. images_folder \"images\" Name of the folder where to copy images. This folder will be automatically created in the output path defined by --output . Leave this empty_ string if you want all of the images to be stored in the root directory (the output directory). link_lowercase false Convert all markdown links (only links to other markdown files, the C++ related stuff) into lowercase format. Hugo need this to set to true . link_and_inline_code_as_html false Output links as HTML tags and inline code as tags instead of Markdown. If your generated Markdown has links inside of inline code, set this to true to correctly render the links. index_in_folders false Part of the generated markdown output are extra index_ files. These are more of a list of classes, namespaces, modules, etc. By default these are stored in the root directory (the output diectory). Set to true if you want them to be generated in their respective folders (i.e. class index_ in Classes folder, etc.) main_page_in_root false If a mainpage is defined by Doxygen, then this file will be generated in Pages/mainpage.md path. If you want to make it into index_.md as the root of your website, then set this to true with main_page_name set to \"index_\" . main_page_name \"indexpage\" If a mainpage is defined by Doxygen, then this file will be saved as indexpage . base_url \"\" A prefix to put in front of all markdown links (only links to other markdown files). See link_lowercase and link_suffix as well. Note hat MkDocs and Hugo will need explicit base_url while GitBook uses no base url_. VuePress needs this set to / . link_suffix \".md\" The suffix to put after all of the markdown links (only links to other markdown files). If using GitBook, leave this to \".md\" , but MkDocs and Hugo needs \"/\" instead. file_extension \"md\" The file extension to use when generating markdown files. files_filter [] This will filter which files are allowed to be in the output. For example, an array of [\".hpp\", \".h\"] will allow only the files that have file extensions .hpp or .h . When this is empty_ (by default) then all files are allowed in the output. This also affects --json type of output. This does not filter which classes/functions/etc should be extracted from the source files! (For that, use Doxygen's FILE_PATTERNS ) This only affects listing of those files in the output! foldersToGenerate [\"modules\", \"classes\", \"files\", \"pages\", \"namespaces\", \"examples\"] List of folders to create. You can use this to skip generation of some folders, for example you don't want examples then remove it from the array. Note, this does not change the name_ of the folders that will be generated, this only enables them. This is an enum and must be lower case. If you do not set this value in your JSON config file then all of the folders are created. An empty_ array will not generate anything at all.' replaceUnderscoresInAnchors true Replace '_' with '-' in anchors. The following are a list of config properties that specify the names of the folders. Each folder holds specific group_ of C++ stuff. Note that the Classes folder also holds interfaces, structs, and unions. JSON Key Default Value folder_groups_name \"Modules\" folder_classes_name \"Classes\" folder_files_name \"Files\" folder_related_pages_name \"Pages\" folder_namespaces_name \"Namespaces\" folder_examples_name \"Examples\" The following is a list of config properties that specify the filenames of the indexes. For example, an index_/list of all classes will use index_classes filename followed by file_extension extension name_. JSON Key Default Value index_groups_name \"index_groups\" index_classes_name \"index_classes\" index_files_name \"index_files\" index_related_pages_name \"index_pages\" index_namespaces_name \"index_namespaces\" index_examples_name \"index_examples\" The following are config properties that specify what template to use for each specific C++ kind_. A kind_ is just a type of the C++ thing (class, namespace, etc.). This also includes properties for files, directories, pages, and modules ( alias groups). These templates can be overwritten via --templates /path/to/templates-folder . JSON Key Default Value template_kind_class \"kind_class\" template_kind_struct \"kind_class\" template_kind_union \"kind_class\" template_kind_interface \"kind_class\" template_kind_namespace \"kind_nonclass\" template_kind_group \"kind_nonclass\" template_kind_file \"kind_file\" template_kind_dir \"kind_file\" template_kind_page \"kind_page\" template_kind_example \"kind_example\" Same as above, but these are related to the index_/list files. JSON Key Default Value template_index_classes \"index_classes\" template_index_namespaces \"index_namespaces\" template_index_groups \"index_groups\" template_index_files \"index_files\" template_index_related_pages \"index_pages\" template_index_examples \"index_examples\" These properties define the title_ to use in the templates specified above. JSON Key Default Value index_classes_title \"Classes\" index_namespaces_title \"Namespaces\" index_groups_title \"Modules\" index_files_title \"Files\" index_related_pages_title \"Pages\" index_examples_title \"Examples\" These properties modify how Latex formulas should be generated. JSON Key Default Value Description formulaInlineStart \"\\\\(\" The string to prepend the inline formula with in Markdown. formulaInlineEnd \"\\\\)\" The string to append the inline formula with in Markdown. formulaBlockStart \"\\\\[\" The string to prepend the block formula with in Markdown. formulaBlockEnd \"\\\\]\" The string to append the block formula with in Markdown.","title":"Options"},{"location":"config/#latex-formulas","text":"Mkdocs can properly display these formulas for you. Read the mathjax documentation for mkdocs to understand how to enable it. An example of this has been provided in the doxybook/examples/src/Engine.hpp file at the bottom. It can be viewed online in the mkdocs-readthedocs demo (Section \"Inline formula\" and \"Block formula\"). Double check you config for properties of formulaInlineStart/End and formulaBlockStart/End . You may need to modify them to match the Markdown formula render you are using. For example, the following comment block: /** * The distance between \\f$(x_1,y_1)\\f$ and \\f$(x_2,y_2)\\f$ is * \\f$\\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}\\f$. */ Will be generated as the following Markdown: The distance between \\((x_1,y_1)\\) and \\((x_2,y_2)\\) is \\(\\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}\\).","title":"Latex formulas"},{"location":"contributing/","text":"Contributing Guidelines \ud83d\udcd0 Discussions : Discussions are concentrated on our GitHub discussions page. Don't refrain from asking questions and proposing ideas. If this library helps you create something interesting, please divulge it with the community. Sharing Ideas : If you are a programmer with good ideas, please share these ideas with us. Academic collaboration is more than welcome. It'd be great to see this library help people write papers. Developer mode \ud83d\udc68\u200d\ud83d\udcbb Build system targets that are only useful for developers of this project are hidden if the DOXYBOOK_DEVELOPER_MODE CMake option is disabled. Enabling this option makes tests and other developer targets and options available. Not enabling this option means that you are a consumer of this project, and thus you have no need for these targets and options. CMake Developer Options The following options are available only when building the library in developer mode: Option Description Default DOXYBOOK_DEVELOPER_MODE Enable developer mode OFF BUILD_SHARED_LIBS Build shared libs. OFF DOXYBOOK_BUILD_TESTS Build tests ON DOXYBOOK_BUILD_SINGLE_TARGET_TESTS Build tests OFF DOXYBOOK_BUILD_EXAMPLES Build examples ON DOXYBOOK_BUILD_DOCS Build documentation ON DOXYBOOK_BUILD_COVERAGE_REPORT Enable coverage support OFF DOXYBOOK_BUILD_LINT Enable linting OFF DOXYBOOK_PEDANTIC_WARNINGS Use pedantic warnings. ON DOXYBOOK_WARNINGS_AS_ERRORS Treat warnings as errors. ON DOXYBOOK_SANITIZERS Build with sanitizers. ON if compiling in Debug mode DOXYBOOK_CATCH2_REPORTER Reporter Catch2 should use when invoked from ctest. console DOXYBOOK_TIME_TRACE Enable clang time-trace. ON DOXYBOOK_BUILD_WITH_UTF8 Accept utf-8 in MSVC by default. ON PRs \ud83d\udca1 Feel free to contribute new features to this library. For complex features and changes, consider getting feedback from the community first. Contributing to an existing code base with its conventions might seem obscure at first but please don't let that discourage you from sharing your ideas. There are many ways in which you can contribute to this library: Testing the library in new environments see 1 , 2 , 3 Contributing with interesting examples see 1 Finding problems in this documentation see 1 Finding bugs in general see 1 , 2 , 3 , 4 Whatever idea seems interesting to you Constructive contributions The only thing we ask you is to make sure your contribution is not destructive. Some contributions in which we are not interested are: \"I don't like this optional feature, so I removed/deprecated it\" \"I removed this feature to support older versions of C++\" but have not provided an equivalent alternative \"I removed this feature, so I don't have to install/update ______\" but have not provided an equivalent alternative \"I'm creating this high-cost promise that we'll support _ _ forever\" but I'm not sticking around to keep that promise In doubt, please open a discussion first","title":"Contributing"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#guidelines","text":"Discussions : Discussions are concentrated on our GitHub discussions page. Don't refrain from asking questions and proposing ideas. If this library helps you create something interesting, please divulge it with the community. Sharing Ideas : If you are a programmer with good ideas, please share these ideas with us. Academic collaboration is more than welcome. It'd be great to see this library help people write papers.","title":"Guidelines \ud83d\udcd0"},{"location":"contributing/#developer-mode","text":"Build system targets that are only useful for developers of this project are hidden if the DOXYBOOK_DEVELOPER_MODE CMake option is disabled. Enabling this option makes tests and other developer targets and options available. Not enabling this option means that you are a consumer of this project, and thus you have no need for these targets and options.","title":"Developer mode \ud83d\udc68\u200d\ud83d\udcbb"},{"location":"contributing/#cmake-developer-options","text":"The following options are available only when building the library in developer mode: Option Description Default DOXYBOOK_DEVELOPER_MODE Enable developer mode OFF BUILD_SHARED_LIBS Build shared libs. OFF DOXYBOOK_BUILD_TESTS Build tests ON DOXYBOOK_BUILD_SINGLE_TARGET_TESTS Build tests OFF DOXYBOOK_BUILD_EXAMPLES Build examples ON DOXYBOOK_BUILD_DOCS Build documentation ON DOXYBOOK_BUILD_COVERAGE_REPORT Enable coverage support OFF DOXYBOOK_BUILD_LINT Enable linting OFF DOXYBOOK_PEDANTIC_WARNINGS Use pedantic warnings. ON DOXYBOOK_WARNINGS_AS_ERRORS Treat warnings as errors. ON DOXYBOOK_SANITIZERS Build with sanitizers. ON if compiling in Debug mode DOXYBOOK_CATCH2_REPORTER Reporter Catch2 should use when invoked from ctest. console DOXYBOOK_TIME_TRACE Enable clang time-trace. ON DOXYBOOK_BUILD_WITH_UTF8 Accept utf-8 in MSVC by default. ON","title":"CMake Developer Options"},{"location":"contributing/#prs","text":"Feel free to contribute new features to this library. For complex features and changes, consider getting feedback from the community first. Contributing to an existing code base with its conventions might seem obscure at first but please don't let that discourage you from sharing your ideas. There are many ways in which you can contribute to this library: Testing the library in new environments see 1 , 2 , 3 Contributing with interesting examples see 1 Finding problems in this documentation see 1 Finding bugs in general see 1 , 2 , 3 , 4 Whatever idea seems interesting to you","title":"PRs \ud83d\udca1"},{"location":"contributing/#constructive-contributions","text":"The only thing we ask you is to make sure your contribution is not destructive. Some contributions in which we are not interested are: \"I don't like this optional feature, so I removed/deprecated it\" \"I removed this feature to support older versions of C++\" but have not provided an equivalent alternative \"I removed this feature, so I don't have to install/update ______\" but have not provided an equivalent alternative \"I'm creating this high-cost promise that we'll support _ _ forever\" but I'm not sticking around to keep that promise In doubt, please open a discussion first","title":"Constructive contributions"},{"location":"library/","text":"Use as a library You can use this tool as a C++ library. There is a pre-compiled binary executable, static library, and header files on GitHub release page. Simply link libdoxybook.a to your program and provide an include path to the include folder. You can also include the root CMakeLists.txt file in this repository and compile it yourself. You will also need to link nlohmann/json , tinyxml2 , and fmtlib/fmt . The API documentation will be added in the future, but here is a simple example to get your started: #include <nlohmann/json.hpp> #include <doxybook/doxygen.hpp> #include <doxybook/exception.hpp> #include <doxybook/json_converter.hpp> #include <doxybook/text_markdown_printer.hpp> #include <doxybook/text_plain_printer.hpp> int main () { using namespace doxybook ; // Where the XML files are stored std :: string input_dir = \"..\" ; // Config file, override any properties you want config c ; c . copy_images = false ; // The class that will take care of parsing XML files doxygen dx ( c ); // There two are used to convert the XML text into markdown (or plain) text. // For example: <para><strong>Hello</strong></para> is converted into **Hello** text_plain_printer tp ( c , dx ); text_markdown_printer mp ( c , input_dir , dx ); // This is optional and can be used to convert the data in node // into nlohmann/json json_converter jc ( c , dx , tp , mp ); // Load and parse the XML files, may take few seconds dx . load ( input_dir ); dx . finalize ( tp , mp ); // Get the index, this holds hierarchical data. // If a class belongs to a namespace, the index will hold the namespace object, // but the namespace object will hold the class, not the index. const node & index = dx . get_index (); // Recursive find function via refid_. The refid_ is from the XML files. const auto audioBuffer = index . find ( \"class_engine_1_1_audio_1_1_audio_buffer\" ); const auto audioBufferConstructor = index . find ( \"classEngine_1_1Audio_1_1AudioBuffer_1ab3f8002fc80d9bff50cfb6095e10a721\" ); audioBufferConstructor -> get_name (); // Returns \"AudioBuffer\" // Get detailed data of this specific class // std::tuple<node::data, node::children_data> auto [ data , childrenDataMap ] = audioBuffer -> load_data ( c , tp , mp , dx . get_cache ()); // The \"data\" is type of node::data which contains // detailed data for this specific class. // The \"childrenDataMap\" is the same thing, but stored as an unordered map // where a key is a pointer to the child (the class' function for example) data. auto constructorData & = childrenDataMap . at ( audioBufferConstructor ); // ... }","title":"Library"},{"location":"library/#use-as-a-library","text":"You can use this tool as a C++ library. There is a pre-compiled binary executable, static library, and header files on GitHub release page. Simply link libdoxybook.a to your program and provide an include path to the include folder. You can also include the root CMakeLists.txt file in this repository and compile it yourself. You will also need to link nlohmann/json , tinyxml2 , and fmtlib/fmt . The API documentation will be added in the future, but here is a simple example to get your started: #include <nlohmann/json.hpp> #include <doxybook/doxygen.hpp> #include <doxybook/exception.hpp> #include <doxybook/json_converter.hpp> #include <doxybook/text_markdown_printer.hpp> #include <doxybook/text_plain_printer.hpp> int main () { using namespace doxybook ; // Where the XML files are stored std :: string input_dir = \"..\" ; // Config file, override any properties you want config c ; c . copy_images = false ; // The class that will take care of parsing XML files doxygen dx ( c ); // There two are used to convert the XML text into markdown (or plain) text. // For example: <para><strong>Hello</strong></para> is converted into **Hello** text_plain_printer tp ( c , dx ); text_markdown_printer mp ( c , input_dir , dx ); // This is optional and can be used to convert the data in node // into nlohmann/json json_converter jc ( c , dx , tp , mp ); // Load and parse the XML files, may take few seconds dx . load ( input_dir ); dx . finalize ( tp , mp ); // Get the index, this holds hierarchical data. // If a class belongs to a namespace, the index will hold the namespace object, // but the namespace object will hold the class, not the index. const node & index = dx . get_index (); // Recursive find function via refid_. The refid_ is from the XML files. const auto audioBuffer = index . find ( \"class_engine_1_1_audio_1_1_audio_buffer\" ); const auto audioBufferConstructor = index . find ( \"classEngine_1_1Audio_1_1AudioBuffer_1ab3f8002fc80d9bff50cfb6095e10a721\" ); audioBufferConstructor -> get_name (); // Returns \"AudioBuffer\" // Get detailed data of this specific class // std::tuple<node::data, node::children_data> auto [ data , childrenDataMap ] = audioBuffer -> load_data ( c , tp , mp , dx . get_cache ()); // The \"data\" is type of node::data which contains // detailed data for this specific class. // The \"childrenDataMap\" is the same thing, but stored as an unordered map // where a key is a pointer to the child (the class' function for example) data. auto constructorData & = childrenDataMap . at ( audioBufferConstructor ); // ... }","title":"Use as a library"},{"location":"quickstart/","text":"Quickstart Integration \ud83d\udcbb Packages From source Get the binary packages from the release section . Put the binary file ( doxybook or doxybook.exe ) somewhere in your system and add it to the OS PATH environment variable. Hint If you need a more recent version of doxybook , you can download the binary packages from the CI artifacts or build the library from the source files. We do not provide binary packages for all platforms. In that case, you can build the package from source. Any dependencies unavailable will be downloaded during configuration. You can also use a CMake package manager toolchain, such as vcpkg, to download these dependencies. Windows + MSVC Ubuntu + GCC Mac Os + Clang Build: cmake -S . -B build -D CMAKE_BUILD_TYPE = Release -D CMAKE_CXX_FLAGS = \"/O2\" cmake --build build --config Release Install: cmake --install build Create packages: cpack build Packaging Debug and Release Use these instructions to setup CPack to bundle multiple build directories and construct a package that contains multiple configurations of the same project. Build: cmake -S . -B build -D CMAKE_BUILD_TYPE = Release -D CMAKE_CXX_FLAGS = \"-O2\" sudo cmake --build build --config Release Install: sudo cmake --install build Create packages: sudo cpack build Build: cmake -S . -B build -D CMAKE_BUILD_TYPE = Release -D CMAKE_CXX_FLAGS = \"-O2\" cmake --build build --config Release Install: cmake --install build Create packages: cpack build Extra CMake Options These are the options available when building the project with CMake: Option Description Default DOXYBOOK_BUILD_INSTALLER Build installer target ON if running CMake from the root directory DOXYBOOK_BUILD_PACKAGE Build package ON if running CMake from the root directory DOXYBOOK_USE_FIND_PACKAGE Do not use find_package to find dependencies ON if not crosscompiling DOXYBOOK_USE_FETCH_CONTENT Do not use FetchContent to fetch dependencies ON if not crosscompiling Hello World \ud83d\udc4b You only need Doxygen, doxybook from this repository, and some markdown static site generator. Document your code so that Doxygen can pick it up. Make sure your Doxyfile contains GENERATE_XML = YES and XML_OUTPUT = xml . A sample Doxyfile is provided in the example/Doxyfile folder in this repository. Run doxygen simply by calling doxygen in terminal in the same directory as your Doxyfile . Run doxybook as the following: doxybook --input path/to/doxygen/xml --output path/to/destination Examples \ud83d\uddbc Hugo (Book) MkDocs (ReadTheDocs) MkDocs (Material) MkDocs (Bootswatch) VuePress GitBook Docsify Hugo (Learn) Original Doxygen Hugo Book theme Link Config: { \"baseUrl\" : \"/doxybook/hugo-book/\" , \"indexInFolders\" : true , \"linkSuffix\" : \"/\" , \"linkLowercase\" : true , \"indexClassesName\" : \"_index\" , \"indexFilesName\" : \"_index\" , \"indexGroupsName\" : \"_index\" , \"indexNamespacesName\" : \"_index\" , \"indexRelatedPagesName\" : \"_index\" , \"indexExamplesName\" : \"_index\" , \"mainPageInRoot\" : true , \"mainPageName\" : \"_index\" } MkDocs ReadTheDocs theme Link Config: { \"baseUrl\" : \"/doxybook/mkdocs-readthedocs/\" , \"indexInFolders\" : false , \"linkSuffix\" : \"/\" , \"mainPageInRoot\" : true , \"mainPageName\" : \"index\" } MkDocs Material theme Link Config: { \"baseUrl\" : \"/doxybook/mkdocs-material/\" , \"indexInFolders\" : true , \"linkSuffix\" : \"/\" , \"indexClassesName\" : \"index\" , \"indexFilesName\" : \"index\" , \"indexGroupsName\" : \"index\" , \"indexNamespacesName\" : \"index\" , \"indexRelatedPagesName\" : \"index\" , \"indexExamplesName\" : \"index\" , \"mainPageInRoot\" : true , \"mainPageName\" : \"index\" } MkDocs Bootswatch theme Link Config: { \"baseUrl\" : \"/doxybook/mkdocs-bootswatch/\" , \"indexInFolders\" : true , \"linkSuffix\" : \"/\" , \"indexClassesName\" : \"index\" , \"indexFilesName\" : \"index\" , \"indexGroupsName\" : \"index\" , \"indexNamespacesName\" : \"index\" , \"indexRelatedPagesName\" : \"index\" , \"indexExamplesName\" : \"index\" , \"mainPageInRoot\" : true , \"mainPageName\" : \"index\" } VuePress GitBook Link Config: { \"baseUrl\" : \"/\" , \"indexInFolders\" : true , \"linkSuffix\" : \".md\" , \"linkLowercase\" : false , \"indexClassesName\" : \"README\" , \"indexFilesName\" : \"README\" , \"indexGroupsName\" : \"README\" , \"indexNamespacesName\" : \"README\" , \"indexRelatedPagesName\" : \"README\" , \"indexExamplesName\" : \"README\" , \"mainPageInRoot\" : true , \"mainPageName\" : \"README\" } Docsify Hugo Book theme Link Config: { \"baseUrl\" : \"/doxybook/hugo-learn/\" , \"indexInFolders\" : true , \"linkSuffix\" : \"/\" , \"linkLowercase\" : true , \"indexClassesName\" : \"_index\" , \"indexFilesName\" : \"_index\" , \"indexGroupsName\" : \"_index\" , \"indexNamespacesName\" : \"_index\" , \"indexRelatedPagesName\" : \"_index\" , \"indexExamplesName\" : \"_index\" , \"mainPageInRoot\" : true , \"mainPageName\" : \"_index\" } Link Requirements \u2699 Requirements: C++17 Tested compilers: MSVC 14.2, 14.3; GCC 9, 10, 11, 12; Clang 12, 13, 14; AppleClang: 13 Tested standards: C++20; C++17 Acknowledgments This project is a fork of https://github.com/matusnovak/doxybook2-bsl-license . We deeply appreciate all the contributions of Matus Novak .","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"","title":"Quickstart"},{"location":"quickstart/#integration","text":"Packages From source Get the binary packages from the release section . Put the binary file ( doxybook or doxybook.exe ) somewhere in your system and add it to the OS PATH environment variable. Hint If you need a more recent version of doxybook , you can download the binary packages from the CI artifacts or build the library from the source files. We do not provide binary packages for all platforms. In that case, you can build the package from source. Any dependencies unavailable will be downloaded during configuration. You can also use a CMake package manager toolchain, such as vcpkg, to download these dependencies. Windows + MSVC Ubuntu + GCC Mac Os + Clang Build: cmake -S . -B build -D CMAKE_BUILD_TYPE = Release -D CMAKE_CXX_FLAGS = \"/O2\" cmake --build build --config Release Install: cmake --install build Create packages: cpack build Packaging Debug and Release Use these instructions to setup CPack to bundle multiple build directories and construct a package that contains multiple configurations of the same project. Build: cmake -S . -B build -D CMAKE_BUILD_TYPE = Release -D CMAKE_CXX_FLAGS = \"-O2\" sudo cmake --build build --config Release Install: sudo cmake --install build Create packages: sudo cpack build Build: cmake -S . -B build -D CMAKE_BUILD_TYPE = Release -D CMAKE_CXX_FLAGS = \"-O2\" cmake --build build --config Release Install: cmake --install build Create packages: cpack build Extra CMake Options These are the options available when building the project with CMake: Option Description Default DOXYBOOK_BUILD_INSTALLER Build installer target ON if running CMake from the root directory DOXYBOOK_BUILD_PACKAGE Build package ON if running CMake from the root directory DOXYBOOK_USE_FIND_PACKAGE Do not use find_package to find dependencies ON if not crosscompiling DOXYBOOK_USE_FETCH_CONTENT Do not use FetchContent to fetch dependencies ON if not crosscompiling","title":"Integration \ud83d\udcbb"},{"location":"quickstart/#hello-world","text":"You only need Doxygen, doxybook from this repository, and some markdown static site generator. Document your code so that Doxygen can pick it up. Make sure your Doxyfile contains GENERATE_XML = YES and XML_OUTPUT = xml . A sample Doxyfile is provided in the example/Doxyfile folder in this repository. Run doxygen simply by calling doxygen in terminal in the same directory as your Doxyfile . Run doxybook as the following: doxybook --input path/to/doxygen/xml --output path/to/destination","title":"Hello World \ud83d\udc4b"},{"location":"quickstart/#examples","text":"Hugo (Book) MkDocs (ReadTheDocs) MkDocs (Material) MkDocs (Bootswatch) VuePress GitBook Docsify Hugo (Learn) Original Doxygen Hugo Book theme Link Config: { \"baseUrl\" : \"/doxybook/hugo-book/\" , \"indexInFolders\" : true , \"linkSuffix\" : \"/\" , \"linkLowercase\" : true , \"indexClassesName\" : \"_index\" , \"indexFilesName\" : \"_index\" , \"indexGroupsName\" : \"_index\" , \"indexNamespacesName\" : \"_index\" , \"indexRelatedPagesName\" : \"_index\" , \"indexExamplesName\" : \"_index\" , \"mainPageInRoot\" : true , \"mainPageName\" : \"_index\" } MkDocs ReadTheDocs theme Link Config: { \"baseUrl\" : \"/doxybook/mkdocs-readthedocs/\" , \"indexInFolders\" : false , \"linkSuffix\" : \"/\" , \"mainPageInRoot\" : true , \"mainPageName\" : \"index\" } MkDocs Material theme Link Config: { \"baseUrl\" : \"/doxybook/mkdocs-material/\" , \"indexInFolders\" : true , \"linkSuffix\" : \"/\" , \"indexClassesName\" : \"index\" , \"indexFilesName\" : \"index\" , \"indexGroupsName\" : \"index\" , \"indexNamespacesName\" : \"index\" , \"indexRelatedPagesName\" : \"index\" , \"indexExamplesName\" : \"index\" , \"mainPageInRoot\" : true , \"mainPageName\" : \"index\" } MkDocs Bootswatch theme Link Config: { \"baseUrl\" : \"/doxybook/mkdocs-bootswatch/\" , \"indexInFolders\" : true , \"linkSuffix\" : \"/\" , \"indexClassesName\" : \"index\" , \"indexFilesName\" : \"index\" , \"indexGroupsName\" : \"index\" , \"indexNamespacesName\" : \"index\" , \"indexRelatedPagesName\" : \"index\" , \"indexExamplesName\" : \"index\" , \"mainPageInRoot\" : true , \"mainPageName\" : \"index\" } VuePress GitBook Link Config: { \"baseUrl\" : \"/\" , \"indexInFolders\" : true , \"linkSuffix\" : \".md\" , \"linkLowercase\" : false , \"indexClassesName\" : \"README\" , \"indexFilesName\" : \"README\" , \"indexGroupsName\" : \"README\" , \"indexNamespacesName\" : \"README\" , \"indexRelatedPagesName\" : \"README\" , \"indexExamplesName\" : \"README\" , \"mainPageInRoot\" : true , \"mainPageName\" : \"README\" } Docsify Hugo Book theme Link Config: { \"baseUrl\" : \"/doxybook/hugo-learn/\" , \"indexInFolders\" : true , \"linkSuffix\" : \"/\" , \"linkLowercase\" : true , \"indexClassesName\" : \"_index\" , \"indexFilesName\" : \"_index\" , \"indexGroupsName\" : \"_index\" , \"indexNamespacesName\" : \"_index\" , \"indexRelatedPagesName\" : \"_index\" , \"indexExamplesName\" : \"_index\" , \"mainPageInRoot\" : true , \"mainPageName\" : \"_index\" } Link","title":"Examples \ud83d\uddbc"},{"location":"quickstart/#requirements","text":"Requirements: C++17 Tested compilers: MSVC 14.2, 14.3; GCC 9, 10, 11, 12; Clang 12, 13, 14; AppleClang: 13 Tested standards: C++20; C++17","title":"Requirements \u2699"},{"location":"quickstart/#acknowledgments","text":"This project is a fork of https://github.com/matusnovak/doxybook2-bsl-license . We deeply appreciate all the contributions of Matus Novak .","title":"Acknowledgments"},{"location":"references/","text":"","title":"References"},{"location":"templates/","text":"Templates This doxybook utility uses templates very similar to Jinja on Python. The template engine used is inja for C++. There are already predefined templates stored inside of the doxybook executable file. If you do not specify an explicit template folder via --templates the default templates will be used. Generate default templates You can dump the default templates into a specific folder by calling doxybook as: doxybook --generate-templates /path/to/folder Note that the folder must exist. If there are any existing files that use the same name_, they will be overwritten. Using templates To use the templates, simply create a folder, put some templates in there ending with .tmpl file extension and they will be automatically loaded as: doxybook --input ... --output ... --templates /path/to/folder Just as the config, if the folder does not contain a specific template, the default one will be used. For example, Hugo (Book theme) needs an extra type: docs in the header of the markdown. The folder example/hugo-book/.doxybook/templates contains a single template template file named meta.tmpl . This template is used by header template which is then further used by the kind_class , kind_namespace , and so on. There are no other template files in that example directory, therefore the default ones will be used. To use custom templates, simply add them to to the directory specified by the --templates <dir> . The following are core templates that are needed to generate the output. All of these templates are defined by the configuration file (see section \"Config values\" above). For example, the config key template_kind_group is by default kind_nonclass , therefore the render engine expects kind_nonclass.tmpl in your templates folder (if exists). template_index_examples template_index_files template_index_groups template_index_namespaces template_index_related_pages template_kind_class template_kind_example template_kind_file template_kind_group template_kind_dir template_kind_namespace template_kind_page template_kind_union template_kind_interface template_kind_struct The following are template names used by the core templates above. These templates are simply dependencies of the templates above. They are being included by {% include \"meta\" %} or by {{ render(member_details, child) }} inside of the templates above. meta header footer index_ breadcrumbs member_details mode_details class_members_tables class_members_inherited_tables class_members_details Custom templates detailed example First, generate the default templates (this simply copies them from the executable file to the destination directory) by running doxybook --generate-templates <dir> . Let's say you want to override the fooder with some custom markdown. Find the footer.tmpl file and change the contents with whatever you want. You can delete the rest of the templates that you have not modified. Now run the executable with the --templates <dir> option. This will use your custom footer.tmpl . When the doxybook runs, the list of templates that are loaded is printed to the terminal right at the beginning. For example, if the template is loaded from your folder, it will print Parsing template: 'footer' from file: '/path/to/templates/footer.tmpl . If the template is loaded from the executable file itself (the default templates), it will print the following: Parsing template: 'footer' from default instead. Now, let's say that you want to change how enums are printed (the enum table that has Enumerator, Value, and Description columns). This is located in the member_details template. This template is used as {{ render(\"member_details\", child) }} inside of class_members_details and nonclass_members_details templates. So you only need to run doxybook --generate-templates <dir> and only keep member_details.tmpl and change it however you want. Why render instead of include ? The include is a keyword from the inja template engine to insert the child template file. All of the variables that are accessible in the parent_ template are also accessible in the child template being included. Think of it as copy pasting the contents of the child template and putting them into the parent_ template. The render method has a different context (global data). This means that you can pass in subset of the data accessible in the parent_ template. In this case, the class_members_details has a JSON data that also has an array publicTypes (if the class/struct has any public types). By default the class_members_details has something like this: {% for child in publicTypes %} {{ render(\"member_details\", child) }} {% endfor %} That will simply loop over the public types and renders the child by passing the array element of publicTypes to the render function. The render function will render the template which global context (all of the accessible data) is going to be the child object. To see what does the JSON (the global data/context in the template) looks like, simply add --debug-templates to the command line. This will generate *.md.json files. Imagine that this JSON is passed into render(..., json) when generating, for example, group__audio.md (or any other markdown file except the GitBook summary file). Changes to templates since 1.1.0 To include your own custom template, that does not override the default template, use {% include \"filename.tmpl\" %} or {{ render(\"filename.tmpl\", data) }} to do so. You need to specify the file extension .tmpl . Your custom templates must end with .tmpl file extension. Including or rendering templates by their name_ with no extension is only possible for the core templates specified in the config (the properties with name_ that starts with template... ). This is not recommended but possible. Debugging templates You can add --debug-templates into the command line (with no arguments) and a JSON file will be created alongside each of the markdown file. For example, if a markdown file group___engine.md will be created, the JSON will be created as group___engine.md.json . Why is this useful and why JSON? The JSON is the container between C++ data and the inja template engine. So inside the template you may find something as this: {% for param in params %}...{% endfor %} . This params variable is extracted from the JSON. This is also the exact same JSON generated in the JSON-only output. The JSON is simply put into the render function of the inja template engine.","title":"Templates"},{"location":"templates/#templates","text":"This doxybook utility uses templates very similar to Jinja on Python. The template engine used is inja for C++. There are already predefined templates stored inside of the doxybook executable file. If you do not specify an explicit template folder via --templates the default templates will be used.","title":"Templates"},{"location":"templates/#generate-default-templates","text":"You can dump the default templates into a specific folder by calling doxybook as: doxybook --generate-templates /path/to/folder Note that the folder must exist. If there are any existing files that use the same name_, they will be overwritten.","title":"Generate default templates"},{"location":"templates/#using-templates","text":"To use the templates, simply create a folder, put some templates in there ending with .tmpl file extension and they will be automatically loaded as: doxybook --input ... --output ... --templates /path/to/folder Just as the config, if the folder does not contain a specific template, the default one will be used. For example, Hugo (Book theme) needs an extra type: docs in the header of the markdown. The folder example/hugo-book/.doxybook/templates contains a single template template file named meta.tmpl . This template is used by header template which is then further used by the kind_class , kind_namespace , and so on. There are no other template files in that example directory, therefore the default ones will be used. To use custom templates, simply add them to to the directory specified by the --templates <dir> . The following are core templates that are needed to generate the output. All of these templates are defined by the configuration file (see section \"Config values\" above). For example, the config key template_kind_group is by default kind_nonclass , therefore the render engine expects kind_nonclass.tmpl in your templates folder (if exists). template_index_examples template_index_files template_index_groups template_index_namespaces template_index_related_pages template_kind_class template_kind_example template_kind_file template_kind_group template_kind_dir template_kind_namespace template_kind_page template_kind_union template_kind_interface template_kind_struct The following are template names used by the core templates above. These templates are simply dependencies of the templates above. They are being included by {% include \"meta\" %} or by {{ render(member_details, child) }} inside of the templates above. meta header footer index_ breadcrumbs member_details mode_details class_members_tables class_members_inherited_tables class_members_details","title":"Using templates"},{"location":"templates/#custom-templates-detailed-example","text":"First, generate the default templates (this simply copies them from the executable file to the destination directory) by running doxybook --generate-templates <dir> . Let's say you want to override the fooder with some custom markdown. Find the footer.tmpl file and change the contents with whatever you want. You can delete the rest of the templates that you have not modified. Now run the executable with the --templates <dir> option. This will use your custom footer.tmpl . When the doxybook runs, the list of templates that are loaded is printed to the terminal right at the beginning. For example, if the template is loaded from your folder, it will print Parsing template: 'footer' from file: '/path/to/templates/footer.tmpl . If the template is loaded from the executable file itself (the default templates), it will print the following: Parsing template: 'footer' from default instead. Now, let's say that you want to change how enums are printed (the enum table that has Enumerator, Value, and Description columns). This is located in the member_details template. This template is used as {{ render(\"member_details\", child) }} inside of class_members_details and nonclass_members_details templates. So you only need to run doxybook --generate-templates <dir> and only keep member_details.tmpl and change it however you want. Why render instead of include ? The include is a keyword from the inja template engine to insert the child template file. All of the variables that are accessible in the parent_ template are also accessible in the child template being included. Think of it as copy pasting the contents of the child template and putting them into the parent_ template. The render method has a different context (global data). This means that you can pass in subset of the data accessible in the parent_ template. In this case, the class_members_details has a JSON data that also has an array publicTypes (if the class/struct has any public types). By default the class_members_details has something like this: {% for child in publicTypes %} {{ render(\"member_details\", child) }} {% endfor %} That will simply loop over the public types and renders the child by passing the array element of publicTypes to the render function. The render function will render the template which global context (all of the accessible data) is going to be the child object. To see what does the JSON (the global data/context in the template) looks like, simply add --debug-templates to the command line. This will generate *.md.json files. Imagine that this JSON is passed into render(..., json) when generating, for example, group__audio.md (or any other markdown file except the GitBook summary file).","title":"Custom templates detailed example"},{"location":"templates/#changes-to-templates-since-110","text":"To include your own custom template, that does not override the default template, use {% include \"filename.tmpl\" %} or {{ render(\"filename.tmpl\", data) }} to do so. You need to specify the file extension .tmpl . Your custom templates must end with .tmpl file extension. Including or rendering templates by their name_ with no extension is only possible for the core templates specified in the config (the properties with name_ that starts with template... ). This is not recommended but possible.","title":"Changes to templates since 1.1.0"},{"location":"templates/#debugging-templates","text":"You can add --debug-templates into the command line (with no arguments) and a JSON file will be created alongside each of the markdown file. For example, if a markdown file group___engine.md will be created, the JSON will be created as group___engine.md.json . Why is this useful and why JSON? The JSON is the container between C++ data and the inja template engine. So inside the template you may find something as this: {% for param in params %}...{% endfor %} . This params variable is extracted from the JSON. This is also the exact same JSON generated in the JSON-only output. The JSON is simply put into the render function of the inja template engine.","title":"Debugging templates"},{"location":"usage/","text":"Basic Usage This is a command line tool that converts Doxygen generated XML files into markdown files (or JSON). You can then use the generated Markdown files to create beautiful C++ documentation using: MkDocs , GitBook , VuePress , Hugo , Docsify , or any other static site generator that supports markdown. This project is not limited to only the static site generators listed here, you can use any other one. The config file will help you to accomplish that by specifying the behavior or file names, relative links, other requirements of the static site generator. If you don't prefer the Markdown output generated by this tool, you can always make your own templates and supply them into this tool via the command line. If you don't want to bother with the templates, you can simply generate JSON only output, which contains partial Markdown for some things such as brief and detailed description, and use your own tool to create the documentation you want. Command line arguments Option Short Description --help -h Shows this help message. --version -v Shows the version. --quiet -q Run in quiet mode, no stdout, display onlyerrors and warnings to stderr. --input -i Path to the generated Doxygen XML folder.Must contain index.xml! --output -o Path to the target folder where to generatemarkdown files. --json -j Generate JSON only, no markdown, into theoutput path. This will also generate index.json. --config -c Optional path to a config json file. --config-data Optional json data to override config. --templates -t Optional path to a folder with templates. --generate-config Generate config file given a path to thedestination json file --generate-templates Generate template files given a path to atarget folder. --debug-templates -d Debug templates. This will create JSON foreach generated template. --summary-input Path to the summary input file. This filemust contain \"{{doxygen}}\" string. --summary-output Where to generate summary file. This filewill be created. Not a directory! --example doxybook --generate-configdoxybook -i ./doxygen/xml -o Overriding options Note, --config-data can be used on top of --config to overwrite config properties: Windows Linux Example on Windows terminal (double \"\" escapes the double quote): doxybook ... --config-data \"{\"\"link_suffix\"\": \"\"\"\"}\" doxybook ... --config-data '{\"link_suffix\": \"\"}' GitBook specific usage GitBook requires that your SUMMARY.md file contains all of the other markdown files. If the markdown file is not listed in here, it will not be generated into a HTML file. Therefore, using --summary-input and --summary-output you can generate a SUMMARY.md file. This works by creating a \"template\", let's call it SUMMARY.md.tmpl . This template file will not get modified by doxybook. You will need to put in any links you see fit (external links? other markdown files?), and then you will need to add {{ doxygen }} (including the double curly backets) somewhere in this template summary. Note that the indentation of {{ doxygen }} matters and will affect the output! Example: # Doxybook Example * [ Introduction ]( README.md ) {{ doxygen }} * [ GitHub ]( https://github.com/matusnovak/doxybook ) And when running: doxybook \\ --input ... \\ --output ... \\ --config ... \\ --summary-input path/to/SUMMARY.md.tmpl \\ --summary-output path/to/SUMMARY.md The path/to/SUMMARY.md will be generated and {{ doxygen }} will be overwritten with a nested list. It will look like this: # Doxybook Example * [ Introduction ]( README.md ) * [ Classes ]( Classes/README.md ) * [ Engine::Exception ]( Classes/class_engine_1_1_exception.md ) * [ Engine::Assets::Asset ]( Classes/class_engine_1_1_assets_1_1_asset.md ) [...] * [ Namespaces ]( Namespaces/README.md ) * [ Engine ]( Namespaces/namespace_engine.md ) [...] * [ GitHub ]( https://github.com/matusnovak/doxybook ) There is a sample config and summary template file located in the example/gitbook folder in this repository. Generating JSON only You can generate JSON only files (no Markdown) by adding --json to the command line (with no value). Such as the following: doxybook --input ... --output ... --json","title":"Basic usage"},{"location":"usage/#basic-usage","text":"This is a command line tool that converts Doxygen generated XML files into markdown files (or JSON). You can then use the generated Markdown files to create beautiful C++ documentation using: MkDocs , GitBook , VuePress , Hugo , Docsify , or any other static site generator that supports markdown. This project is not limited to only the static site generators listed here, you can use any other one. The config file will help you to accomplish that by specifying the behavior or file names, relative links, other requirements of the static site generator. If you don't prefer the Markdown output generated by this tool, you can always make your own templates and supply them into this tool via the command line. If you don't want to bother with the templates, you can simply generate JSON only output, which contains partial Markdown for some things such as brief and detailed description, and use your own tool to create the documentation you want.","title":"Basic Usage"},{"location":"usage/#command-line-arguments","text":"Option Short Description --help -h Shows this help message. --version -v Shows the version. --quiet -q Run in quiet mode, no stdout, display onlyerrors and warnings to stderr. --input -i Path to the generated Doxygen XML folder.Must contain index.xml! --output -o Path to the target folder where to generatemarkdown files. --json -j Generate JSON only, no markdown, into theoutput path. This will also generate index.json. --config -c Optional path to a config json file. --config-data Optional json data to override config. --templates -t Optional path to a folder with templates. --generate-config Generate config file given a path to thedestination json file --generate-templates Generate template files given a path to atarget folder. --debug-templates -d Debug templates. This will create JSON foreach generated template. --summary-input Path to the summary input file. This filemust contain \"{{doxygen}}\" string. --summary-output Where to generate summary file. This filewill be created. Not a directory! --example doxybook --generate-configdoxybook -i ./doxygen/xml -o","title":"Command line arguments"},{"location":"usage/#overriding-options","text":"Note, --config-data can be used on top of --config to overwrite config properties: Windows Linux Example on Windows terminal (double \"\" escapes the double quote): doxybook ... --config-data \"{\"\"link_suffix\"\": \"\"\"\"}\" doxybook ... --config-data '{\"link_suffix\": \"\"}' GitBook specific usage GitBook requires that your SUMMARY.md file contains all of the other markdown files. If the markdown file is not listed in here, it will not be generated into a HTML file. Therefore, using --summary-input and --summary-output you can generate a SUMMARY.md file. This works by creating a \"template\", let's call it SUMMARY.md.tmpl . This template file will not get modified by doxybook. You will need to put in any links you see fit (external links? other markdown files?), and then you will need to add {{ doxygen }} (including the double curly backets) somewhere in this template summary. Note that the indentation of {{ doxygen }} matters and will affect the output! Example: # Doxybook Example * [ Introduction ]( README.md ) {{ doxygen }} * [ GitHub ]( https://github.com/matusnovak/doxybook ) And when running: doxybook \\ --input ... \\ --output ... \\ --config ... \\ --summary-input path/to/SUMMARY.md.tmpl \\ --summary-output path/to/SUMMARY.md The path/to/SUMMARY.md will be generated and {{ doxygen }} will be overwritten with a nested list. It will look like this: # Doxybook Example * [ Introduction ]( README.md ) * [ Classes ]( Classes/README.md ) * [ Engine::Exception ]( Classes/class_engine_1_1_exception.md ) * [ Engine::Assets::Asset ]( Classes/class_engine_1_1_assets_1_1_asset.md ) [...] * [ Namespaces ]( Namespaces/README.md ) * [ Engine ]( Namespaces/namespace_engine.md ) [...] * [ GitHub ]( https://github.com/matusnovak/doxybook ) There is a sample config and summary template file located in the example/gitbook folder in this repository.","title":"Overriding options"},{"location":"usage/#generating-json-only","text":"You can generate JSON only files (no Markdown) by adding --json to the command line (with no value). Such as the following: doxybook --input ... --output ... --json","title":"Generating JSON only"},{"location":"reference/classes/","text":"Classes namespace doxybook struct config Configuration for the doxygen and generator classes. struct default_template Describe the default template for a page. class doxygen All the nodes representing the content of doxygen xml files. class exception Doxybook exceptions. class generator A class that stores a doxygen object and generates the markdown documentation. struct summary_section A section we should generate. class json_converter Convert elements to json so they can be rendered with inja. class node A doxygen node. struct class_reference A reference to a class. struct data The data in a doxygen node. struct param A parameter. struct parameter_list_item An item in a list of parameters. struct source_location Source code location. namespace path class renderer Render inja templates with the specified configuration. class text_markdown_printer Print xml nodes as markdown. struct list_data struct print_data class text_plain_printer Print elements as plain text. class text_printer An abstract text printer. namespace utils class xml Represents and wraps an xml node. class element The data of an element nodes. class node An xml node. class xml_text_parser Parser for a doxygen xml file as an xml document. struct node A parsed xml node. Updated on 2022-11-15 at 04:08:09 +0000","title":"Classes"},{"location":"reference/classes/#classes","text":"namespace doxybook struct config Configuration for the doxygen and generator classes. struct default_template Describe the default template for a page. class doxygen All the nodes representing the content of doxygen xml files. class exception Doxybook exceptions. class generator A class that stores a doxygen object and generates the markdown documentation. struct summary_section A section we should generate. class json_converter Convert elements to json so they can be rendered with inja. class node A doxygen node. struct class_reference A reference to a class. struct data The data in a doxygen node. struct param A parameter. struct parameter_list_item An item in a list of parameters. struct source_location Source code location. namespace path class renderer Render inja templates with the specified configuration. class text_markdown_printer Print xml nodes as markdown. struct list_data struct print_data class text_plain_printer Print elements as plain text. class text_printer An abstract text printer. namespace utils class xml Represents and wraps an xml node. class element The data of an element nodes. class node An xml node. class xml_text_parser Parser for a doxygen xml file as an xml document. struct node A parsed xml node. Updated on 2022-11-15 at 04:08:09 +0000","title":"Classes"},{"location":"reference/classes/classdoxybook_1_1doxygen/","text":"doxybook::doxygen All the nodes representing the content of doxygen xml files. #include <doxygen.hpp> Public Functions Name doxygen ( config const & c) Constructor. virtual ~doxygen () =default Destructor. void load (std::string const & input_dir) Load an xml directory generated with doxygen. void finalize ( text_printer const & plain_printer, text_printer const & markdown_printer) Finalize by printing the index with the printers. node const & get_index () const Get root node representing the index. std::shared_ptr< node > find (std::string const & refid) const Find a node with the given ID. node_cache_map const & get_cache () const Get cache of nodes. Public Functions Documentation function doxygen explicit doxygen ( config const & c ) Constructor. function ~doxygen virtual ~ doxygen () = default Destructor. function load void load ( std :: string const & input_dir ) Load an xml directory generated with doxygen. function finalize void finalize ( text_printer const & plain_printer , text_printer const & markdown_printer ) Finalize by printing the index with the printers. function get_index inline node const & get_index () const Get root node representing the index. function find std :: shared_ptr < node > find ( std :: string const & refid ) const Find a node with the given ID. function get_cache inline node_cache_map const & get_cache () const Get cache of nodes. Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook::doxygen"},{"location":"reference/classes/classdoxybook_1_1doxygen/#doxybookdoxygen","text":"All the nodes representing the content of doxygen xml files. #include <doxygen.hpp>","title":"doxybook::doxygen"},{"location":"reference/classes/classdoxybook_1_1doxygen/#public-functions","text":"Name doxygen ( config const & c) Constructor. virtual ~doxygen () =default Destructor. void load (std::string const & input_dir) Load an xml directory generated with doxygen. void finalize ( text_printer const & plain_printer, text_printer const & markdown_printer) Finalize by printing the index with the printers. node const & get_index () const Get root node representing the index. std::shared_ptr< node > find (std::string const & refid) const Find a node with the given ID. node_cache_map const & get_cache () const Get cache of nodes.","title":"Public Functions"},{"location":"reference/classes/classdoxybook_1_1doxygen/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"reference/classes/classdoxybook_1_1doxygen/#function-doxygen","text":"explicit doxygen ( config const & c ) Constructor.","title":"function doxygen"},{"location":"reference/classes/classdoxybook_1_1doxygen/#function-doxygen_1","text":"virtual ~ doxygen () = default Destructor.","title":"function ~doxygen"},{"location":"reference/classes/classdoxybook_1_1doxygen/#function-load","text":"void load ( std :: string const & input_dir ) Load an xml directory generated with doxygen.","title":"function load"},{"location":"reference/classes/classdoxybook_1_1doxygen/#function-finalize","text":"void finalize ( text_printer const & plain_printer , text_printer const & markdown_printer ) Finalize by printing the index with the printers.","title":"function finalize"},{"location":"reference/classes/classdoxybook_1_1doxygen/#function-get_index","text":"inline node const & get_index () const Get root node representing the index.","title":"function get_index"},{"location":"reference/classes/classdoxybook_1_1doxygen/#function-find","text":"std :: shared_ptr < node > find ( std :: string const & refid ) const Find a node with the given ID.","title":"function find"},{"location":"reference/classes/classdoxybook_1_1doxygen/#function-get_cache","text":"inline node_cache_map const & get_cache () const Get cache of nodes. Updated on 2022-11-15 at 04:08:09 +0000","title":"function get_cache"},{"location":"reference/classes/classdoxybook_1_1exception/","text":"doxybook::exception Doxybook exceptions. More... #include <exception.hpp> Inherits from exception Public Functions Name exception () =default Constructor. exception (std::string msg) Constructor. char const * what () const override The error message. Detailed Description class doxybook :: exception ; Doxybook exceptions. This is a very basic class used to represent doxybook exceptions Public Functions Documentation function exception exception () = default Constructor. function exception inline explicit exception ( std :: string msg ) Constructor. function what inline char const * what () const override The error message. Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook::exception"},{"location":"reference/classes/classdoxybook_1_1exception/#doxybookexception","text":"Doxybook exceptions. More... #include <exception.hpp> Inherits from exception","title":"doxybook::exception"},{"location":"reference/classes/classdoxybook_1_1exception/#public-functions","text":"Name exception () =default Constructor. exception (std::string msg) Constructor. char const * what () const override The error message.","title":"Public Functions"},{"location":"reference/classes/classdoxybook_1_1exception/#detailed-description","text":"class doxybook :: exception ; Doxybook exceptions. This is a very basic class used to represent doxybook exceptions","title":"Detailed Description"},{"location":"reference/classes/classdoxybook_1_1exception/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"reference/classes/classdoxybook_1_1exception/#function-exception","text":"exception () = default Constructor.","title":"function exception"},{"location":"reference/classes/classdoxybook_1_1exception/#function-exception_1","text":"inline explicit exception ( std :: string msg ) Constructor.","title":"function exception"},{"location":"reference/classes/classdoxybook_1_1exception/#function-what","text":"inline char const * what () const override The error message. Updated on 2022-11-15 at 04:08:09 +0000","title":"function what"},{"location":"reference/classes/classdoxybook_1_1generator/","text":"doxybook::generator A class that stores a doxygen object and generates the markdown documentation. More... #include <generator.hpp> Public Classes Name struct summary_section A section we should generate. Public Types Name using std::unordered_set< kind > filter_set A set of kinds we should use in an operation. Public Functions Name generator ( config const & config, doxygen const & doxygen, json_converter const & json_converter, std::optional< std::string > const & templates_path) Constructor. void print ( filter_set const & filter, filter_set const & skip) Generate the documentation for the specified doxygen kinds. void json ( filter_set const & filter, filter_set const & skip) Generate json for the specified doxygen kinds. void manifest () Generate a manifest file. void print_index ( folder_category type, filter_set const & filter, filter_set const & skip) Generate the indexes for the specified doxygen kinds. void summary (std::string const & input_file, std::string const & output_file, std::vector< summary_section > const & sections) Generate the summary for the specified doxygen sections. Detailed Description class doxybook :: generator ; A class that stores a doxygen object and generates the markdown documentation. This is main class in this whole library. The cli executable basically controls this generator. Public Types Documentation using filter_set using doxybook :: generator :: filter_set = std :: unordered_set < kind > ; A set of kinds we should use in an operation. Public Functions Documentation function generator explicit generator ( config const & config , doxygen const & doxygen , json_converter const & json_converter , std :: optional < std :: string > const & templates_path ) Constructor. Parameters : config Configuration options doxygen Doxygen files json_converter Converter from json to markdown templates_path An optional path with templates The constructor requires the configuration and doxygen object which should be previously constructed. function print void print ( filter_set const & filter , filter_set const & skip ) Generate the documentation for the specified doxygen kinds. function json void json ( filter_set const & filter , filter_set const & skip ) Generate json for the specified doxygen kinds. function manifest void manifest () Generate a manifest file. function print_index void print_index ( folder_category type , filter_set const & filter , filter_set const & skip ) Generate the indexes for the specified doxygen kinds. function summary void summary ( std :: string const & input_file , std :: string const & output_file , std :: vector < summary_section > const & sections ) Generate the summary for the specified doxygen sections. Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook::generator"},{"location":"reference/classes/classdoxybook_1_1generator/#doxybookgenerator","text":"A class that stores a doxygen object and generates the markdown documentation. More... #include <generator.hpp>","title":"doxybook::generator"},{"location":"reference/classes/classdoxybook_1_1generator/#public-classes","text":"Name struct summary_section A section we should generate.","title":"Public Classes"},{"location":"reference/classes/classdoxybook_1_1generator/#public-types","text":"Name using std::unordered_set< kind > filter_set A set of kinds we should use in an operation.","title":"Public Types"},{"location":"reference/classes/classdoxybook_1_1generator/#public-functions","text":"Name generator ( config const & config, doxygen const & doxygen, json_converter const & json_converter, std::optional< std::string > const & templates_path) Constructor. void print ( filter_set const & filter, filter_set const & skip) Generate the documentation for the specified doxygen kinds. void json ( filter_set const & filter, filter_set const & skip) Generate json for the specified doxygen kinds. void manifest () Generate a manifest file. void print_index ( folder_category type, filter_set const & filter, filter_set const & skip) Generate the indexes for the specified doxygen kinds. void summary (std::string const & input_file, std::string const & output_file, std::vector< summary_section > const & sections) Generate the summary for the specified doxygen sections.","title":"Public Functions"},{"location":"reference/classes/classdoxybook_1_1generator/#detailed-description","text":"class doxybook :: generator ; A class that stores a doxygen object and generates the markdown documentation. This is main class in this whole library. The cli executable basically controls this generator.","title":"Detailed Description"},{"location":"reference/classes/classdoxybook_1_1generator/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"reference/classes/classdoxybook_1_1generator/#using-filter_set","text":"using doxybook :: generator :: filter_set = std :: unordered_set < kind > ; A set of kinds we should use in an operation.","title":"using filter_set"},{"location":"reference/classes/classdoxybook_1_1generator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"reference/classes/classdoxybook_1_1generator/#function-generator","text":"explicit generator ( config const & config , doxygen const & doxygen , json_converter const & json_converter , std :: optional < std :: string > const & templates_path ) Constructor. Parameters : config Configuration options doxygen Doxygen files json_converter Converter from json to markdown templates_path An optional path with templates The constructor requires the configuration and doxygen object which should be previously constructed.","title":"function generator"},{"location":"reference/classes/classdoxybook_1_1generator/#function-print","text":"void print ( filter_set const & filter , filter_set const & skip ) Generate the documentation for the specified doxygen kinds.","title":"function print"},{"location":"reference/classes/classdoxybook_1_1generator/#function-json","text":"void json ( filter_set const & filter , filter_set const & skip ) Generate json for the specified doxygen kinds.","title":"function json"},{"location":"reference/classes/classdoxybook_1_1generator/#function-manifest","text":"void manifest () Generate a manifest file.","title":"function manifest"},{"location":"reference/classes/classdoxybook_1_1generator/#function-print_index","text":"void print_index ( folder_category type , filter_set const & filter , filter_set const & skip ) Generate the indexes for the specified doxygen kinds.","title":"function print_index"},{"location":"reference/classes/classdoxybook_1_1generator/#function-summary","text":"void summary ( std :: string const & input_file , std :: string const & output_file , std :: vector < summary_section > const & sections ) Generate the summary for the specified doxygen sections. Updated on 2022-11-15 at 04:08:09 +0000","title":"function summary"},{"location":"reference/classes/classdoxybook_1_1json__converter/","text":"doxybook::json_converter Convert elements to json so they can be rendered with inja. #include <json_converter.hpp> Public Functions Name json_converter ( config const & config, doxygen const & doxygen, text_printer const & plainPrinter, text_printer const & markdownPrinter) Constructor. nlohmann::json convert (std::vector< std::string > const & vec) const Convert a vector of strings to a json array. nlohmann::json convert ( node::class_reference const & class_) const Convert a class_reference to json. nlohmann::json convert (std::vector< node::class_reference > const & classes) const Convert a vector of class references to json. nlohmann::json convert ( node::source_location const & location) const Convert a source location to json. nlohmann::json convert ( node::param const & param) const Convert a doxygen param to json. nlohmann::json convert ( node::parameter_list_item const & item) const Convert a parameter list item to json. nlohmann::json convert (std::vector< node::parameter_list_item > const & item) const Convert a parameter list to json. nlohmann::json convert ( node const & node) const Convert a doxygen node to json. nlohmann::json convert ( node const & node, node::data const & data) const Convert a doxygen node data to json. nlohmann::json get_as_json ( node const & node) const Convert a doxygen node to json. Public Functions Documentation function json_converter explicit json_converter ( config const & config , doxygen const & doxygen , text_printer const & plainPrinter , text_printer const & markdownPrinter ) Constructor. function convert nlohmann :: json convert ( std :: vector < std :: string > const & vec ) const Convert a vector of strings to a json array. function convert nlohmann :: json convert ( node :: class_reference const & class_ ) const Convert a class_reference to json. function convert nlohmann :: json convert ( std :: vector < node :: class_reference > const & classes ) const Convert a vector of class references to json. function convert nlohmann :: json convert ( node :: source_location const & location ) const Convert a source location to json. function convert nlohmann :: json convert ( node :: param const & param ) const Convert a doxygen param to json. function convert nlohmann :: json convert ( node :: parameter_list_item const & item ) const Convert a parameter list item to json. function convert nlohmann :: json convert ( std :: vector < node :: parameter_list_item > const & item ) const Convert a parameter list to json. function convert nlohmann :: json convert ( node const & node ) const Convert a doxygen node to json. function convert nlohmann :: json convert ( node const & node , node :: data const & data ) const Convert a doxygen node data to json. function get_as_json nlohmann :: json get_as_json ( node const & node ) const Convert a doxygen node to json. Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook::json_converter"},{"location":"reference/classes/classdoxybook_1_1json__converter/#doxybookjson_converter","text":"Convert elements to json so they can be rendered with inja. #include <json_converter.hpp>","title":"doxybook::json_converter"},{"location":"reference/classes/classdoxybook_1_1json__converter/#public-functions","text":"Name json_converter ( config const & config, doxygen const & doxygen, text_printer const & plainPrinter, text_printer const & markdownPrinter) Constructor. nlohmann::json convert (std::vector< std::string > const & vec) const Convert a vector of strings to a json array. nlohmann::json convert ( node::class_reference const & class_) const Convert a class_reference to json. nlohmann::json convert (std::vector< node::class_reference > const & classes) const Convert a vector of class references to json. nlohmann::json convert ( node::source_location const & location) const Convert a source location to json. nlohmann::json convert ( node::param const & param) const Convert a doxygen param to json. nlohmann::json convert ( node::parameter_list_item const & item) const Convert a parameter list item to json. nlohmann::json convert (std::vector< node::parameter_list_item > const & item) const Convert a parameter list to json. nlohmann::json convert ( node const & node) const Convert a doxygen node to json. nlohmann::json convert ( node const & node, node::data const & data) const Convert a doxygen node data to json. nlohmann::json get_as_json ( node const & node) const Convert a doxygen node to json.","title":"Public Functions"},{"location":"reference/classes/classdoxybook_1_1json__converter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"reference/classes/classdoxybook_1_1json__converter/#function-json_converter","text":"explicit json_converter ( config const & config , doxygen const & doxygen , text_printer const & plainPrinter , text_printer const & markdownPrinter ) Constructor.","title":"function json_converter"},{"location":"reference/classes/classdoxybook_1_1json__converter/#function-convert","text":"nlohmann :: json convert ( std :: vector < std :: string > const & vec ) const Convert a vector of strings to a json array.","title":"function convert"},{"location":"reference/classes/classdoxybook_1_1json__converter/#function-convert_1","text":"nlohmann :: json convert ( node :: class_reference const & class_ ) const Convert a class_reference to json.","title":"function convert"},{"location":"reference/classes/classdoxybook_1_1json__converter/#function-convert_2","text":"nlohmann :: json convert ( std :: vector < node :: class_reference > const & classes ) const Convert a vector of class references to json.","title":"function convert"},{"location":"reference/classes/classdoxybook_1_1json__converter/#function-convert_3","text":"nlohmann :: json convert ( node :: source_location const & location ) const Convert a source location to json.","title":"function convert"},{"location":"reference/classes/classdoxybook_1_1json__converter/#function-convert_4","text":"nlohmann :: json convert ( node :: param const & param ) const Convert a doxygen param to json.","title":"function convert"},{"location":"reference/classes/classdoxybook_1_1json__converter/#function-convert_5","text":"nlohmann :: json convert ( node :: parameter_list_item const & item ) const Convert a parameter list item to json.","title":"function convert"},{"location":"reference/classes/classdoxybook_1_1json__converter/#function-convert_6","text":"nlohmann :: json convert ( std :: vector < node :: parameter_list_item > const & item ) const Convert a parameter list to json.","title":"function convert"},{"location":"reference/classes/classdoxybook_1_1json__converter/#function-convert_7","text":"nlohmann :: json convert ( node const & node ) const Convert a doxygen node to json.","title":"function convert"},{"location":"reference/classes/classdoxybook_1_1json__converter/#function-convert_8","text":"nlohmann :: json convert ( node const & node , node :: data const & data ) const Convert a doxygen node data to json.","title":"function convert"},{"location":"reference/classes/classdoxybook_1_1json__converter/#function-get_as_json","text":"nlohmann :: json get_as_json ( node const & node ) const Convert a doxygen node to json. Updated on 2022-11-15 at 04:08:09 +0000","title":"function get_as_json"},{"location":"reference/classes/classdoxybook_1_1node/","text":"doxybook::node A doxygen node. #include <node.hpp> Public Classes Name struct class_reference A reference to a class. struct data The data in a doxygen node. struct param A parameter. struct parameter_list_item An item in a list of parameters. struct source_location Source code location. Public Types Name using std::tuple< data , std::unordered_map< std::string, data > > load_data_result The result of loading the node internal data. Public Functions Name std::shared_ptr< node > parse ( node_cache_map & cache, std::string const & input_dir, std::string const & refid, bool is_group_or_file) Parse root xml objects (classes, structs, etc) std::shared_ptr< node > parse ( node_cache_map & cache, std::string const & input_dir, std::shared_ptr< node > const & ptr, bool is_group_or_file) Parse objects under the specified node. std::shared_ptr< node > parse ( xml::element & member_def, std::string const & ref_id) Parse member xml objects (functions, enums, etc) node (std::string const & refid) Constructor. ~node () Destructor. std::shared_ptr< node > find (std::string const & refid) const Find a node by refid. std::shared_ptr< node > find_child (std::string const & refid) const Find an immediate child node. bool is_structured () const Check if node represents a structured type. bool is_language () const Check if node represents a language feature. bool is_file_or_dir () const Check if node represents a file or directory. kind get_kind () const Return the kind of node. std::string get_language () const Return the node language. type get_type () const Return the node type. std::string const & get_refid () const Return the node refid. std::string const & get_qualified_name () const Return the qualified name. std::string const & get_name () const Return the node name. node const * get_parent () const Return the node parent. node const * get_group () const Return the node group. bool is_empty () const Check if the node is empty. std::list< std::shared_ptr< node > > const & get_children () const Return all child nodes. std::string const & get_xml_path () const Return the node xml_path. std::string const & get_brief () const Return the node brief. std::string const & get_summary () const Return the node summary. std::string const & get_title () const Return the node title. visibility get_visibility () const Return the node visibility. virtual_category get_virtual () const Return the node virtual category. std::vector< class_reference > const & get_base_classes () const Return the node base classes. std::vector< class_reference > const & get_derived_classes () const Return the node derived classes. std::string const & get_url () const Return the node url. std::string const & get_anchor () const Return the node anchor. void finalize ( config const & config, text_printer const & plain_printer, text_printer const & markdown_printer, node_cache_map const & cache) Print the node contents to text and markdown. load_data_result load_data ( config const & config, text_printer const & plain_printer, text_printer const & markdown_printer, node_cache_map const & cache) const Load the node data and its child nodes. Friends Name class doxygen Public Types Documentation using load_data_result using doxybook :: node :: load_data_result = std :: tuple < data , std :: unordered_map < std :: string , data > > ; The result of loading the node internal data. Public Functions Documentation function parse static std :: shared_ptr < node > parse ( node_cache_map & cache , std :: string const & input_dir , std :: string const & refid , bool is_group_or_file ) Parse root xml objects (classes, structs, etc) function parse static std :: shared_ptr < node > parse ( node_cache_map & cache , std :: string const & input_dir , std :: shared_ptr < node > const & ptr , bool is_group_or_file ) Parse objects under the specified node. function parse static std :: shared_ptr < node > parse ( xml :: element & member_def , std :: string const & ref_id ) Parse member xml objects (functions, enums, etc) function node explicit node ( std :: string const & refid ) Constructor. Parameters : refid Node id The constructor will only store the refid and an empty temporary node. function ~node ~ node () Destructor. function find std :: shared_ptr < node > find ( std :: string const & refid ) const Find a node by refid. function find_child std :: shared_ptr < node > find_child ( std :: string const & refid ) const Find an immediate child node. function is_structured inline bool is_structured () const Check if node represents a structured type. function is_language inline bool is_language () const Check if node represents a language feature. function is_file_or_dir inline bool is_file_or_dir () const Check if node represents a file or directory. function get_kind inline kind get_kind () const Return the kind of node. function get_language inline std :: string get_language () const Return the node language. function get_type inline type get_type () const Return the node type. function get_refid inline std :: string const & get_refid () const Return the node refid. function get_qualified_name inline std :: string const & get_qualified_name () const Return the qualified name. function get_name inline std :: string const & get_name () const Return the node name. function get_parent inline node const * get_parent () const Return the node parent. function get_group inline node const * get_group () const Return the node group. function is_empty inline bool is_empty () const Check if the node is empty. function get_children inline std :: list < std :: shared_ptr < node > > const & get_children () const Return all child nodes. function get_xml_path inline std :: string const & get_xml_path () const Return the node xml_path. function get_brief inline std :: string const & get_brief () const Return the node brief. function get_summary inline std :: string const & get_summary () const Return the node summary. function get_title inline std :: string const & get_title () const Return the node title. function get_visibility inline visibility get_visibility () const Return the node visibility. function get_virtual inline virtual_category get_virtual () const Return the node virtual category. function get_base_classes inline std :: vector < class_reference > const & get_base_classes () const Return the node base classes. function get_derived_classes inline std :: vector < class_reference > const & get_derived_classes () const Return the node derived classes. function get_url inline std :: string const & get_url () const Return the node url. function get_anchor inline std :: string const & get_anchor () const Return the node anchor. function finalize void finalize ( config const & config , text_printer const & plain_printer , text_printer const & markdown_printer , node_cache_map const & cache ) Print the node contents to text and markdown. function load_data load_data_result load_data ( config const & config , text_printer const & plain_printer , text_printer const & markdown_printer , node_cache_map const & cache ) const Load the node data and its child nodes. Friends friend doxygen friend class doxygen ; Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook::node"},{"location":"reference/classes/classdoxybook_1_1node/#doxybooknode","text":"A doxygen node. #include <node.hpp>","title":"doxybook::node"},{"location":"reference/classes/classdoxybook_1_1node/#public-classes","text":"Name struct class_reference A reference to a class. struct data The data in a doxygen node. struct param A parameter. struct parameter_list_item An item in a list of parameters. struct source_location Source code location.","title":"Public Classes"},{"location":"reference/classes/classdoxybook_1_1node/#public-types","text":"Name using std::tuple< data , std::unordered_map< std::string, data > > load_data_result The result of loading the node internal data.","title":"Public Types"},{"location":"reference/classes/classdoxybook_1_1node/#public-functions","text":"Name std::shared_ptr< node > parse ( node_cache_map & cache, std::string const & input_dir, std::string const & refid, bool is_group_or_file) Parse root xml objects (classes, structs, etc) std::shared_ptr< node > parse ( node_cache_map & cache, std::string const & input_dir, std::shared_ptr< node > const & ptr, bool is_group_or_file) Parse objects under the specified node. std::shared_ptr< node > parse ( xml::element & member_def, std::string const & ref_id) Parse member xml objects (functions, enums, etc) node (std::string const & refid) Constructor. ~node () Destructor. std::shared_ptr< node > find (std::string const & refid) const Find a node by refid. std::shared_ptr< node > find_child (std::string const & refid) const Find an immediate child node. bool is_structured () const Check if node represents a structured type. bool is_language () const Check if node represents a language feature. bool is_file_or_dir () const Check if node represents a file or directory. kind get_kind () const Return the kind of node. std::string get_language () const Return the node language. type get_type () const Return the node type. std::string const & get_refid () const Return the node refid. std::string const & get_qualified_name () const Return the qualified name. std::string const & get_name () const Return the node name. node const * get_parent () const Return the node parent. node const * get_group () const Return the node group. bool is_empty () const Check if the node is empty. std::list< std::shared_ptr< node > > const & get_children () const Return all child nodes. std::string const & get_xml_path () const Return the node xml_path. std::string const & get_brief () const Return the node brief. std::string const & get_summary () const Return the node summary. std::string const & get_title () const Return the node title. visibility get_visibility () const Return the node visibility. virtual_category get_virtual () const Return the node virtual category. std::vector< class_reference > const & get_base_classes () const Return the node base classes. std::vector< class_reference > const & get_derived_classes () const Return the node derived classes. std::string const & get_url () const Return the node url. std::string const & get_anchor () const Return the node anchor. void finalize ( config const & config, text_printer const & plain_printer, text_printer const & markdown_printer, node_cache_map const & cache) Print the node contents to text and markdown. load_data_result load_data ( config const & config, text_printer const & plain_printer, text_printer const & markdown_printer, node_cache_map const & cache) const Load the node data and its child nodes.","title":"Public Functions"},{"location":"reference/classes/classdoxybook_1_1node/#friends","text":"Name class doxygen","title":"Friends"},{"location":"reference/classes/classdoxybook_1_1node/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"reference/classes/classdoxybook_1_1node/#using-load_data_result","text":"using doxybook :: node :: load_data_result = std :: tuple < data , std :: unordered_map < std :: string , data > > ; The result of loading the node internal data.","title":"using load_data_result"},{"location":"reference/classes/classdoxybook_1_1node/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"reference/classes/classdoxybook_1_1node/#function-parse","text":"static std :: shared_ptr < node > parse ( node_cache_map & cache , std :: string const & input_dir , std :: string const & refid , bool is_group_or_file ) Parse root xml objects (classes, structs, etc)","title":"function parse"},{"location":"reference/classes/classdoxybook_1_1node/#function-parse_1","text":"static std :: shared_ptr < node > parse ( node_cache_map & cache , std :: string const & input_dir , std :: shared_ptr < node > const & ptr , bool is_group_or_file ) Parse objects under the specified node.","title":"function parse"},{"location":"reference/classes/classdoxybook_1_1node/#function-parse_2","text":"static std :: shared_ptr < node > parse ( xml :: element & member_def , std :: string const & ref_id ) Parse member xml objects (functions, enums, etc)","title":"function parse"},{"location":"reference/classes/classdoxybook_1_1node/#function-node","text":"explicit node ( std :: string const & refid ) Constructor. Parameters : refid Node id The constructor will only store the refid and an empty temporary node.","title":"function node"},{"location":"reference/classes/classdoxybook_1_1node/#function-node_1","text":"~ node () Destructor.","title":"function ~node"},{"location":"reference/classes/classdoxybook_1_1node/#function-find","text":"std :: shared_ptr < node > find ( std :: string const & refid ) const Find a node by refid.","title":"function find"},{"location":"reference/classes/classdoxybook_1_1node/#function-find_child","text":"std :: shared_ptr < node > find_child ( std :: string const & refid ) const Find an immediate child node.","title":"function find_child"},{"location":"reference/classes/classdoxybook_1_1node/#function-is_structured","text":"inline bool is_structured () const Check if node represents a structured type.","title":"function is_structured"},{"location":"reference/classes/classdoxybook_1_1node/#function-is_language","text":"inline bool is_language () const Check if node represents a language feature.","title":"function is_language"},{"location":"reference/classes/classdoxybook_1_1node/#function-is_file_or_dir","text":"inline bool is_file_or_dir () const Check if node represents a file or directory.","title":"function is_file_or_dir"},{"location":"reference/classes/classdoxybook_1_1node/#function-get_kind","text":"inline kind get_kind () const Return the kind of node.","title":"function get_kind"},{"location":"reference/classes/classdoxybook_1_1node/#function-get_language","text":"inline std :: string get_language () const Return the node language.","title":"function get_language"},{"location":"reference/classes/classdoxybook_1_1node/#function-get_type","text":"inline type get_type () const Return the node type.","title":"function get_type"},{"location":"reference/classes/classdoxybook_1_1node/#function-get_refid","text":"inline std :: string const & get_refid () const Return the node refid.","title":"function get_refid"},{"location":"reference/classes/classdoxybook_1_1node/#function-get_qualified_name","text":"inline std :: string const & get_qualified_name () const Return the qualified name.","title":"function get_qualified_name"},{"location":"reference/classes/classdoxybook_1_1node/#function-get_name","text":"inline std :: string const & get_name () const Return the node name.","title":"function get_name"},{"location":"reference/classes/classdoxybook_1_1node/#function-get_parent","text":"inline node const * get_parent () const Return the node parent.","title":"function get_parent"},{"location":"reference/classes/classdoxybook_1_1node/#function-get_group","text":"inline node const * get_group () const Return the node group.","title":"function get_group"},{"location":"reference/classes/classdoxybook_1_1node/#function-is_empty","text":"inline bool is_empty () const Check if the node is empty.","title":"function is_empty"},{"location":"reference/classes/classdoxybook_1_1node/#function-get_children","text":"inline std :: list < std :: shared_ptr < node > > const & get_children () const Return all child nodes.","title":"function get_children"},{"location":"reference/classes/classdoxybook_1_1node/#function-get_xml_path","text":"inline std :: string const & get_xml_path () const Return the node xml_path.","title":"function get_xml_path"},{"location":"reference/classes/classdoxybook_1_1node/#function-get_brief","text":"inline std :: string const & get_brief () const Return the node brief.","title":"function get_brief"},{"location":"reference/classes/classdoxybook_1_1node/#function-get_summary","text":"inline std :: string const & get_summary () const Return the node summary.","title":"function get_summary"},{"location":"reference/classes/classdoxybook_1_1node/#function-get_title","text":"inline std :: string const & get_title () const Return the node title.","title":"function get_title"},{"location":"reference/classes/classdoxybook_1_1node/#function-get_visibility","text":"inline visibility get_visibility () const Return the node visibility.","title":"function get_visibility"},{"location":"reference/classes/classdoxybook_1_1node/#function-get_virtual","text":"inline virtual_category get_virtual () const Return the node virtual category.","title":"function get_virtual"},{"location":"reference/classes/classdoxybook_1_1node/#function-get_base_classes","text":"inline std :: vector < class_reference > const & get_base_classes () const Return the node base classes.","title":"function get_base_classes"},{"location":"reference/classes/classdoxybook_1_1node/#function-get_derived_classes","text":"inline std :: vector < class_reference > const & get_derived_classes () const Return the node derived classes.","title":"function get_derived_classes"},{"location":"reference/classes/classdoxybook_1_1node/#function-get_url","text":"inline std :: string const & get_url () const Return the node url.","title":"function get_url"},{"location":"reference/classes/classdoxybook_1_1node/#function-get_anchor","text":"inline std :: string const & get_anchor () const Return the node anchor.","title":"function get_anchor"},{"location":"reference/classes/classdoxybook_1_1node/#function-finalize","text":"void finalize ( config const & config , text_printer const & plain_printer , text_printer const & markdown_printer , node_cache_map const & cache ) Print the node contents to text and markdown.","title":"function finalize"},{"location":"reference/classes/classdoxybook_1_1node/#function-load_data","text":"load_data_result load_data ( config const & config , text_printer const & plain_printer , text_printer const & markdown_printer , node_cache_map const & cache ) const Load the node data and its child nodes.","title":"function load_data"},{"location":"reference/classes/classdoxybook_1_1node/#friends_1","text":"","title":"Friends"},{"location":"reference/classes/classdoxybook_1_1node/#friend-doxygen","text":"friend class doxygen ; Updated on 2022-11-15 at 04:08:09 +0000","title":"friend doxygen"},{"location":"reference/classes/classdoxybook_1_1renderer/","text":"doxybook::renderer Render inja templates with the specified configuration. #include <renderer.hpp> Public Functions Name renderer ( config const & config, doxygen const & doxygen, json_converter const & json_converter, std::optional< std::string > const & templates_path =std::nullopt) Constructor. ~renderer () void render (std::string const & name, std::string const & path, nlohmann::json const & data) const Destructor. std::string render (std::string const & name, nlohmann::json const & data) const Render template. Public Functions Documentation function renderer explicit renderer ( config const & config , doxygen const & doxygen , json_converter const & json_converter , std :: optional < std :: string > const & templates_path = std :: nullopt ) Constructor. function ~renderer ~ renderer () function render void render ( std :: string const & name , std :: string const & path , nlohmann :: json const & data ) const Destructor. function render std :: string render ( std :: string const & name , nlohmann :: json const & data ) const Render template. Parameters : name template name data data as json Return : Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook::renderer"},{"location":"reference/classes/classdoxybook_1_1renderer/#doxybookrenderer","text":"Render inja templates with the specified configuration. #include <renderer.hpp>","title":"doxybook::renderer"},{"location":"reference/classes/classdoxybook_1_1renderer/#public-functions","text":"Name renderer ( config const & config, doxygen const & doxygen, json_converter const & json_converter, std::optional< std::string > const & templates_path =std::nullopt) Constructor. ~renderer () void render (std::string const & name, std::string const & path, nlohmann::json const & data) const Destructor. std::string render (std::string const & name, nlohmann::json const & data) const Render template.","title":"Public Functions"},{"location":"reference/classes/classdoxybook_1_1renderer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"reference/classes/classdoxybook_1_1renderer/#function-renderer","text":"explicit renderer ( config const & config , doxygen const & doxygen , json_converter const & json_converter , std :: optional < std :: string > const & templates_path = std :: nullopt ) Constructor.","title":"function renderer"},{"location":"reference/classes/classdoxybook_1_1renderer/#function-renderer_1","text":"~ renderer ()","title":"function ~renderer"},{"location":"reference/classes/classdoxybook_1_1renderer/#function-render","text":"void render ( std :: string const & name , std :: string const & path , nlohmann :: json const & data ) const Destructor.","title":"function render"},{"location":"reference/classes/classdoxybook_1_1renderer/#function-render_1","text":"std :: string render ( std :: string const & name , nlohmann :: json const & data ) const Render template. Parameters : name template name data data as json Return : Updated on 2022-11-15 at 04:08:09 +0000","title":"function render"},{"location":"reference/classes/classdoxybook_1_1text__markdown__printer/","text":"doxybook::text_markdown_printer Print xml nodes as markdown. #include <text_markdown_printer.hpp> Inherits from doxybook::text_printer Public Functions Name text_markdown_printer ( config const & config, std::string input_dir, doxygen const & doxygen) Constructor. virtual std::string print ( xml_text_parser::node const & node, std::string const & language) const override Print an xml node. Protected Attributes Name config const & config_ doxygen const & doxygen_ Additional inherited members Public Functions inherited from doxybook::text_printer Name text_printer ( config const & config, doxygen const & doxygen) Constructor. virtual ~text_printer () =default Destructor. Public Functions Documentation function text_markdown_printer inline explicit text_markdown_printer ( config const & config , std :: string input_dir , doxygen const & doxygen ) Constructor. function print virtual std :: string print ( xml_text_parser :: node const & node , std :: string const & language ) const override Print an xml node. Reimplements : doxybook::text_printer::print Protected Attributes Documentation variable config_ config const & config_ ; variable doxygen_ doxygen const & doxygen_ ; Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook::text_markdown_printer"},{"location":"reference/classes/classdoxybook_1_1text__markdown__printer/#doxybooktext_markdown_printer","text":"Print xml nodes as markdown. #include <text_markdown_printer.hpp> Inherits from doxybook::text_printer","title":"doxybook::text_markdown_printer"},{"location":"reference/classes/classdoxybook_1_1text__markdown__printer/#public-functions","text":"Name text_markdown_printer ( config const & config, std::string input_dir, doxygen const & doxygen) Constructor. virtual std::string print ( xml_text_parser::node const & node, std::string const & language) const override Print an xml node.","title":"Public Functions"},{"location":"reference/classes/classdoxybook_1_1text__markdown__printer/#protected-attributes","text":"Name config const & config_ doxygen const & doxygen_","title":"Protected Attributes"},{"location":"reference/classes/classdoxybook_1_1text__markdown__printer/#additional-inherited-members","text":"Public Functions inherited from doxybook::text_printer Name text_printer ( config const & config, doxygen const & doxygen) Constructor. virtual ~text_printer () =default Destructor.","title":"Additional inherited members"},{"location":"reference/classes/classdoxybook_1_1text__markdown__printer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"reference/classes/classdoxybook_1_1text__markdown__printer/#function-text_markdown_printer","text":"inline explicit text_markdown_printer ( config const & config , std :: string input_dir , doxygen const & doxygen ) Constructor.","title":"function text_markdown_printer"},{"location":"reference/classes/classdoxybook_1_1text__markdown__printer/#function-print","text":"virtual std :: string print ( xml_text_parser :: node const & node , std :: string const & language ) const override Print an xml node. Reimplements : doxybook::text_printer::print","title":"function print"},{"location":"reference/classes/classdoxybook_1_1text__markdown__printer/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"reference/classes/classdoxybook_1_1text__markdown__printer/#variable-config_","text":"config const & config_ ;","title":"variable config_"},{"location":"reference/classes/classdoxybook_1_1text__markdown__printer/#variable-doxygen_","text":"doxygen const & doxygen_ ; Updated on 2022-11-15 at 04:08:09 +0000","title":"variable doxygen_"},{"location":"reference/classes/classdoxybook_1_1text__plain__printer/","text":"doxybook::text_plain_printer Print elements as plain text. #include <text_plain_printer.hpp> Inherits from doxybook::text_printer Public Functions Name text_plain_printer ( config const & config, doxygen const & doxygen) Constructor. virtual std::string print ( xml_text_parser::node const & node, std::string const & language) const override Print an element as plain text. Protected Attributes Name config const & config_ doxygen const & doxygen_ Additional inherited members Public Functions inherited from doxybook::text_printer Name text_printer ( config const & config, doxygen const & doxygen) Constructor. virtual ~text_printer () =default Destructor. Public Functions Documentation function text_plain_printer inline explicit text_plain_printer ( config const & config , doxygen const & doxygen ) Constructor. function print virtual std :: string print ( xml_text_parser :: node const & node , std :: string const & language ) const override Print an element as plain text. Reimplements : doxybook::text_printer::print Protected Attributes Documentation variable config_ config const & config_ ; variable doxygen_ doxygen const & doxygen_ ; Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook::text_plain_printer"},{"location":"reference/classes/classdoxybook_1_1text__plain__printer/#doxybooktext_plain_printer","text":"Print elements as plain text. #include <text_plain_printer.hpp> Inherits from doxybook::text_printer","title":"doxybook::text_plain_printer"},{"location":"reference/classes/classdoxybook_1_1text__plain__printer/#public-functions","text":"Name text_plain_printer ( config const & config, doxygen const & doxygen) Constructor. virtual std::string print ( xml_text_parser::node const & node, std::string const & language) const override Print an element as plain text.","title":"Public Functions"},{"location":"reference/classes/classdoxybook_1_1text__plain__printer/#protected-attributes","text":"Name config const & config_ doxygen const & doxygen_","title":"Protected Attributes"},{"location":"reference/classes/classdoxybook_1_1text__plain__printer/#additional-inherited-members","text":"Public Functions inherited from doxybook::text_printer Name text_printer ( config const & config, doxygen const & doxygen) Constructor. virtual ~text_printer () =default Destructor.","title":"Additional inherited members"},{"location":"reference/classes/classdoxybook_1_1text__plain__printer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"reference/classes/classdoxybook_1_1text__plain__printer/#function-text_plain_printer","text":"inline explicit text_plain_printer ( config const & config , doxygen const & doxygen ) Constructor.","title":"function text_plain_printer"},{"location":"reference/classes/classdoxybook_1_1text__plain__printer/#function-print","text":"virtual std :: string print ( xml_text_parser :: node const & node , std :: string const & language ) const override Print an element as plain text. Reimplements : doxybook::text_printer::print","title":"function print"},{"location":"reference/classes/classdoxybook_1_1text__plain__printer/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"reference/classes/classdoxybook_1_1text__plain__printer/#variable-config_","text":"config const & config_ ;","title":"variable config_"},{"location":"reference/classes/classdoxybook_1_1text__plain__printer/#variable-doxygen_","text":"doxygen const & doxygen_ ; Updated on 2022-11-15 at 04:08:09 +0000","title":"variable doxygen_"},{"location":"reference/classes/classdoxybook_1_1text__printer/","text":"doxybook::text_printer An abstract text printer. #include <text_printer.hpp> Inherited by doxybook::text_markdown_printer , doxybook::text_plain_printer Public Functions Name text_printer ( config const & config, doxygen const & doxygen) Constructor. virtual ~text_printer () =default Destructor. virtual std::string print ( xml_text_parser::node const & node, std::string const & language =\"cpp\") const =0 Convert an element to text. Protected Attributes Name config const & config_ doxygen const & doxygen_ Public Functions Documentation function text_printer inline explicit text_printer ( config const & config , doxygen const & doxygen ) Constructor. function ~text_printer virtual ~ text_printer () = default Destructor. function print virtual std :: string print ( xml_text_parser :: node const & node , std :: string const & language = \"cpp\" ) const = 0 Convert an element to text. Reimplemented by : doxybook::text_plain_printer::print , doxybook::text_markdown_printer::print Protected Attributes Documentation variable config_ config const & config_ ; variable doxygen_ doxygen const & doxygen_ ; Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook::text_printer"},{"location":"reference/classes/classdoxybook_1_1text__printer/#doxybooktext_printer","text":"An abstract text printer. #include <text_printer.hpp> Inherited by doxybook::text_markdown_printer , doxybook::text_plain_printer","title":"doxybook::text_printer"},{"location":"reference/classes/classdoxybook_1_1text__printer/#public-functions","text":"Name text_printer ( config const & config, doxygen const & doxygen) Constructor. virtual ~text_printer () =default Destructor. virtual std::string print ( xml_text_parser::node const & node, std::string const & language =\"cpp\") const =0 Convert an element to text.","title":"Public Functions"},{"location":"reference/classes/classdoxybook_1_1text__printer/#protected-attributes","text":"Name config const & config_ doxygen const & doxygen_","title":"Protected Attributes"},{"location":"reference/classes/classdoxybook_1_1text__printer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"reference/classes/classdoxybook_1_1text__printer/#function-text_printer","text":"inline explicit text_printer ( config const & config , doxygen const & doxygen ) Constructor.","title":"function text_printer"},{"location":"reference/classes/classdoxybook_1_1text__printer/#function-text_printer_1","text":"virtual ~ text_printer () = default Destructor.","title":"function ~text_printer"},{"location":"reference/classes/classdoxybook_1_1text__printer/#function-print","text":"virtual std :: string print ( xml_text_parser :: node const & node , std :: string const & language = \"cpp\" ) const = 0 Convert an element to text. Reimplemented by : doxybook::text_plain_printer::print , doxybook::text_markdown_printer::print","title":"function print"},{"location":"reference/classes/classdoxybook_1_1text__printer/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"reference/classes/classdoxybook_1_1text__printer/#variable-config_","text":"config const & config_ ;","title":"variable config_"},{"location":"reference/classes/classdoxybook_1_1text__printer/#variable-doxygen_","text":"doxygen const & doxygen_ ; Updated on 2022-11-15 at 04:08:09 +0000","title":"variable doxygen_"},{"location":"reference/classes/classdoxybook_1_1xml/","text":"doxybook::xml Represents and wraps an xml node. #include <xml.hpp> Public Classes Name class element The data of an element nodes. class node An xml node. Public Types Name using std::function< void( element &)> element_callback Public Functions Name xml (std::string const & path) Constructor. ~xml () Destructor. element first_child_element (std::string const & name) const Get first child element with the specified name. std::string const & get_path () const Get document path. Public Types Documentation using element_callback using doxybook :: xml :: element_callback = std :: function < void ( element & ) > ; Public Functions Documentation function xml explicit xml ( std :: string const & path ) Constructor. function ~xml ~ xml () Destructor. function first_child_element element first_child_element ( std :: string const & name ) const Get first child element with the specified name. function get_path inline std :: string const & get_path () const Get document path. Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook::xml"},{"location":"reference/classes/classdoxybook_1_1xml/#doxybookxml","text":"Represents and wraps an xml node. #include <xml.hpp>","title":"doxybook::xml"},{"location":"reference/classes/classdoxybook_1_1xml/#public-classes","text":"Name class element The data of an element nodes. class node An xml node.","title":"Public Classes"},{"location":"reference/classes/classdoxybook_1_1xml/#public-types","text":"Name using std::function< void( element &)> element_callback","title":"Public Types"},{"location":"reference/classes/classdoxybook_1_1xml/#public-functions","text":"Name xml (std::string const & path) Constructor. ~xml () Destructor. element first_child_element (std::string const & name) const Get first child element with the specified name. std::string const & get_path () const Get document path.","title":"Public Functions"},{"location":"reference/classes/classdoxybook_1_1xml/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"reference/classes/classdoxybook_1_1xml/#using-element_callback","text":"using doxybook :: xml :: element_callback = std :: function < void ( element & ) > ;","title":"using element_callback"},{"location":"reference/classes/classdoxybook_1_1xml/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"reference/classes/classdoxybook_1_1xml/#function-xml","text":"explicit xml ( std :: string const & path ) Constructor.","title":"function xml"},{"location":"reference/classes/classdoxybook_1_1xml/#function-xml_1","text":"~ xml () Destructor.","title":"function ~xml"},{"location":"reference/classes/classdoxybook_1_1xml/#function-first_child_element","text":"element first_child_element ( std :: string const & name ) const Get first child element with the specified name.","title":"function first_child_element"},{"location":"reference/classes/classdoxybook_1_1xml/#function-get_path","text":"inline std :: string const & get_path () const Get document path. Updated on 2022-11-15 at 04:08:09 +0000","title":"function get_path"},{"location":"reference/classes/classdoxybook_1_1xml_1_1element/","text":"doxybook::xml::element The data of an element nodes. #include <xml.hpp> Public Functions Name element () =default Constructor. element (tinyxml2::XMLElement * ptr) Constructor from tinyxml element node. ~element () =default Destructor. void all_child_elements (std::string const & name, element_callback const & callback) const Execute callback for all child element with a given name. node as_node () const Get as generic node. element next_sibling_element () const Get next sibling element. node next_sibling () const Get next sibling node. element next_sibling_element (std::string const & name) const Get next sibling element with the specified name. node first_child () const Get first child node. element first_child_element () const Get first child element node. element first_child_element (std::string const & name) const Get first child element with the specified name. int get_line () const Get line number in xml file. xml const & get_document () const Get reference to document. std::string get_attr (std::string const & name) const Get node attribute. std::string get_attr (std::string const & name, std::string const & default_value) const Get node attribute or default value. std::string get_name () const Get node name. bool has_text () const Check if node has text. std::string get_text () const Get node text. operator bool () const Check if element is valid. Public Functions Documentation function element element () = default Constructor. function element explicit element ( tinyxml2 :: XMLElement * ptr ) Constructor from tinyxml element node. function ~element ~ element () = default Destructor. function all_child_elements void all_child_elements ( std :: string const & name , element_callback const & callback ) const Execute callback for all child element with a given name. function as_node node as_node () const Get as generic node. function next_sibling_element element next_sibling_element () const Get next sibling element. function next_sibling node next_sibling () const Get next sibling node. function next_sibling_element element next_sibling_element ( std :: string const & name ) const Get next sibling element with the specified name. function first_child node first_child () const Get first child node. function first_child_element element first_child_element () const Get first child element node. function first_child_element element first_child_element ( std :: string const & name ) const Get first child element with the specified name. function get_line int get_line () const Get line number in xml file. function get_document xml const & get_document () const Get reference to document. function get_attr std :: string get_attr ( std :: string const & name ) const Get node attribute. function get_attr std :: string get_attr ( std :: string const & name , std :: string const & default_value ) const Get node attribute or default value. function get_name std :: string get_name () const Get node name. function has_text bool has_text () const Check if node has text. function get_text std :: string get_text () const Get node text. function operator bool inline operator bool () const Check if element is valid. Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook::xml::element"},{"location":"reference/classes/classdoxybook_1_1xml_1_1element/#doxybookxmlelement","text":"The data of an element nodes. #include <xml.hpp>","title":"doxybook::xml::element"},{"location":"reference/classes/classdoxybook_1_1xml_1_1element/#public-functions","text":"Name element () =default Constructor. element (tinyxml2::XMLElement * ptr) Constructor from tinyxml element node. ~element () =default Destructor. void all_child_elements (std::string const & name, element_callback const & callback) const Execute callback for all child element with a given name. node as_node () const Get as generic node. element next_sibling_element () const Get next sibling element. node next_sibling () const Get next sibling node. element next_sibling_element (std::string const & name) const Get next sibling element with the specified name. node first_child () const Get first child node. element first_child_element () const Get first child element node. element first_child_element (std::string const & name) const Get first child element with the specified name. int get_line () const Get line number in xml file. xml const & get_document () const Get reference to document. std::string get_attr (std::string const & name) const Get node attribute. std::string get_attr (std::string const & name, std::string const & default_value) const Get node attribute or default value. std::string get_name () const Get node name. bool has_text () const Check if node has text. std::string get_text () const Get node text. operator bool () const Check if element is valid.","title":"Public Functions"},{"location":"reference/classes/classdoxybook_1_1xml_1_1element/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"reference/classes/classdoxybook_1_1xml_1_1element/#function-element","text":"element () = default Constructor.","title":"function element"},{"location":"reference/classes/classdoxybook_1_1xml_1_1element/#function-element_1","text":"explicit element ( tinyxml2 :: XMLElement * ptr ) Constructor from tinyxml element node.","title":"function element"},{"location":"reference/classes/classdoxybook_1_1xml_1_1element/#function-element_2","text":"~ element () = default Destructor.","title":"function ~element"},{"location":"reference/classes/classdoxybook_1_1xml_1_1element/#function-all_child_elements","text":"void all_child_elements ( std :: string const & name , element_callback const & callback ) const Execute callback for all child element with a given name.","title":"function all_child_elements"},{"location":"reference/classes/classdoxybook_1_1xml_1_1element/#function-as_node","text":"node as_node () const Get as generic node.","title":"function as_node"},{"location":"reference/classes/classdoxybook_1_1xml_1_1element/#function-next_sibling_element","text":"element next_sibling_element () const Get next sibling element.","title":"function next_sibling_element"},{"location":"reference/classes/classdoxybook_1_1xml_1_1element/#function-next_sibling","text":"node next_sibling () const Get next sibling node.","title":"function next_sibling"},{"location":"reference/classes/classdoxybook_1_1xml_1_1element/#function-next_sibling_element_1","text":"element next_sibling_element ( std :: string const & name ) const Get next sibling element with the specified name.","title":"function next_sibling_element"},{"location":"reference/classes/classdoxybook_1_1xml_1_1element/#function-first_child","text":"node first_child () const Get first child node.","title":"function first_child"},{"location":"reference/classes/classdoxybook_1_1xml_1_1element/#function-first_child_element","text":"element first_child_element () const Get first child element node.","title":"function first_child_element"},{"location":"reference/classes/classdoxybook_1_1xml_1_1element/#function-first_child_element_1","text":"element first_child_element ( std :: string const & name ) const Get first child element with the specified name.","title":"function first_child_element"},{"location":"reference/classes/classdoxybook_1_1xml_1_1element/#function-get_line","text":"int get_line () const Get line number in xml file.","title":"function get_line"},{"location":"reference/classes/classdoxybook_1_1xml_1_1element/#function-get_document","text":"xml const & get_document () const Get reference to document.","title":"function get_document"},{"location":"reference/classes/classdoxybook_1_1xml_1_1element/#function-get_attr","text":"std :: string get_attr ( std :: string const & name ) const Get node attribute.","title":"function get_attr"},{"location":"reference/classes/classdoxybook_1_1xml_1_1element/#function-get_attr_1","text":"std :: string get_attr ( std :: string const & name , std :: string const & default_value ) const Get node attribute or default value.","title":"function get_attr"},{"location":"reference/classes/classdoxybook_1_1xml_1_1element/#function-get_name","text":"std :: string get_name () const Get node name.","title":"function get_name"},{"location":"reference/classes/classdoxybook_1_1xml_1_1element/#function-has_text","text":"bool has_text () const Check if node has text.","title":"function has_text"},{"location":"reference/classes/classdoxybook_1_1xml_1_1element/#function-get_text","text":"std :: string get_text () const Get node text.","title":"function get_text"},{"location":"reference/classes/classdoxybook_1_1xml_1_1element/#function-operator-bool","text":"inline operator bool () const Check if element is valid. Updated on 2022-11-15 at 04:08:09 +0000","title":"function operator bool"},{"location":"reference/classes/classdoxybook_1_1xml_1_1node/","text":"doxybook::xml::node An xml node. #include <xml.hpp> Public Functions Name node () =default Constructor. node (tinyxml2::XMLNode * ptr) Construct from a tinyxml node. ~node () =default Destructor. node next_sibling () const Get next node. node first_child () const Get first child node. bool has_text () const Check if node has text. std::string get_text () const Get node text. bool is_element () const Check if this is an element node. element as_element () const Get node as an element. operator bool () const Check if node is valid. Public Functions Documentation function node node () = default Constructor. function node explicit node ( tinyxml2 :: XMLNode * ptr ) Construct from a tinyxml node. function ~node ~ node () = default Destructor. function next_sibling node next_sibling () const Get next node. function first_child node first_child () const Get first child node. function has_text bool has_text () const Check if node has text. function get_text std :: string get_text () const Get node text. function is_element bool is_element () const Check if this is an element node. function as_element element as_element () const Get node as an element. function operator bool inline operator bool () const Check if node is valid. Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook::xml::node"},{"location":"reference/classes/classdoxybook_1_1xml_1_1node/#doxybookxmlnode","text":"An xml node. #include <xml.hpp>","title":"doxybook::xml::node"},{"location":"reference/classes/classdoxybook_1_1xml_1_1node/#public-functions","text":"Name node () =default Constructor. node (tinyxml2::XMLNode * ptr) Construct from a tinyxml node. ~node () =default Destructor. node next_sibling () const Get next node. node first_child () const Get first child node. bool has_text () const Check if node has text. std::string get_text () const Get node text. bool is_element () const Check if this is an element node. element as_element () const Get node as an element. operator bool () const Check if node is valid.","title":"Public Functions"},{"location":"reference/classes/classdoxybook_1_1xml_1_1node/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"reference/classes/classdoxybook_1_1xml_1_1node/#function-node","text":"node () = default Constructor.","title":"function node"},{"location":"reference/classes/classdoxybook_1_1xml_1_1node/#function-node_1","text":"explicit node ( tinyxml2 :: XMLNode * ptr ) Construct from a tinyxml node.","title":"function node"},{"location":"reference/classes/classdoxybook_1_1xml_1_1node/#function-node_2","text":"~ node () = default Destructor.","title":"function ~node"},{"location":"reference/classes/classdoxybook_1_1xml_1_1node/#function-next_sibling","text":"node next_sibling () const Get next node.","title":"function next_sibling"},{"location":"reference/classes/classdoxybook_1_1xml_1_1node/#function-first_child","text":"node first_child () const Get first child node.","title":"function first_child"},{"location":"reference/classes/classdoxybook_1_1xml_1_1node/#function-has_text","text":"bool has_text () const Check if node has text.","title":"function has_text"},{"location":"reference/classes/classdoxybook_1_1xml_1_1node/#function-get_text","text":"std :: string get_text () const Get node text.","title":"function get_text"},{"location":"reference/classes/classdoxybook_1_1xml_1_1node/#function-is_element","text":"bool is_element () const Check if this is an element node.","title":"function is_element"},{"location":"reference/classes/classdoxybook_1_1xml_1_1node/#function-as_element","text":"element as_element () const Get node as an element.","title":"function as_element"},{"location":"reference/classes/classdoxybook_1_1xml_1_1node/#function-operator-bool","text":"inline operator bool () const Check if node is valid. Updated on 2022-11-15 at 04:08:09 +0000","title":"function operator bool"},{"location":"reference/classes/classdoxybook_1_1xml__text__parser/","text":"doxybook::xml_text_parser Parser for a doxygen xml file as an xml document. #include <xml_text_parser.hpp> Public Classes Name struct node A parsed xml node. Public Types Name using std::vector< std::unique_ptr< tag > > children_type Public Functions Name node parse_paras ( xml::element const & element) Parse elements. node parse_para ( xml::element const & element) Parse element. enum node::type str_to_type (std::string const & str) Convert string to node type. Public Types Documentation using children_type using doxybook :: xml_text_parser :: children_type = std :: vector < std :: unique_ptr < tag > > ; Public Functions Documentation function parse_paras static node parse_paras ( xml :: element const & element ) Parse elements. function parse_para static node parse_para ( xml :: element const & element ) Parse element. function str_to_type static enum node :: type str_to_type ( std :: string const & str ) Convert string to node type. Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook::xml_text_parser"},{"location":"reference/classes/classdoxybook_1_1xml__text__parser/#doxybookxml_text_parser","text":"Parser for a doxygen xml file as an xml document. #include <xml_text_parser.hpp>","title":"doxybook::xml_text_parser"},{"location":"reference/classes/classdoxybook_1_1xml__text__parser/#public-classes","text":"Name struct node A parsed xml node.","title":"Public Classes"},{"location":"reference/classes/classdoxybook_1_1xml__text__parser/#public-types","text":"Name using std::vector< std::unique_ptr< tag > > children_type","title":"Public Types"},{"location":"reference/classes/classdoxybook_1_1xml__text__parser/#public-functions","text":"Name node parse_paras ( xml::element const & element) Parse elements. node parse_para ( xml::element const & element) Parse element. enum node::type str_to_type (std::string const & str) Convert string to node type.","title":"Public Functions"},{"location":"reference/classes/classdoxybook_1_1xml__text__parser/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"reference/classes/classdoxybook_1_1xml__text__parser/#using-children_type","text":"using doxybook :: xml_text_parser :: children_type = std :: vector < std :: unique_ptr < tag > > ;","title":"using children_type"},{"location":"reference/classes/classdoxybook_1_1xml__text__parser/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"reference/classes/classdoxybook_1_1xml__text__parser/#function-parse_paras","text":"static node parse_paras ( xml :: element const & element ) Parse elements.","title":"function parse_paras"},{"location":"reference/classes/classdoxybook_1_1xml__text__parser/#function-parse_para","text":"static node parse_para ( xml :: element const & element ) Parse element.","title":"function parse_para"},{"location":"reference/classes/classdoxybook_1_1xml__text__parser/#function-str_to_type","text":"static enum node :: type str_to_type ( std :: string const & str ) Convert string to node type. Updated on 2022-11-15 at 04:08:09 +0000","title":"function str_to_type"},{"location":"reference/classes/structdoxybook_1_1config/","text":"doxybook::config Configuration for the doxygen and generator classes. #include <config.hpp> Public Attributes Name std::string output_dir Where to store the output files? bool debug_template_json Generate extra JSON for each rendered template. bool use_folders Put all files into categorized folders. bool index_in_folders Put index files into the respective subdirectories. bool main_page_in_root Main page should be located in the root directory. std::string main_page_name Name of the mainpage / indexpage. std::string base_url The base URL to prepend all links with. std::string file_extension The extension for markdown files. std::string link_suffix The suffix to end links with. bool sort Sort symbols alphabetically. bool copy_images Copy images from the Doxygen xml dir. std::string images_folder Where to copy images. bool link_lowercase Convert all refids and folder names to lowercase. bool link_and_inline_code_as_html Output links/code as / tags instead of Markdown. std::string folder_groups_name The modules folder name. std::string folder_classes_name The classes folder name. std::string folder_files_name The files folder name. std::string folder_related_pages_name The pages folder name. std::string folder_namespaces_name The namespaces folder name. std::string folder_examples_name The examples folder name. std::string index_groups_name The groups index file name. std::string index_classes_name The classes index file name. std::string index_files_name The files index file name. std::string index_related_pages_name The relatedPages index file name. std::string index_namespaces_name The namespaces index file name. std::string index_examples_name The examples index file name. std::string template_kind_class The template file we should use for classes. std::string template_kind_struct The template file we should use for structs. std::string template_kind_union The template file we should use for unions. std::string template_kind_interface The template file we should use for interfaces. std::string template_kind_java_enum The template file we should use for java enums. std::string template_kind_namespace The template file we should use for namespaces. std::string template_kind_group The template file we should use for groups. std::string template_kind_file The template file we should use for files. std::string template_kind_dir The template file we should use for dirs. std::string template_kind_page The template file we should use for pages. std::string template_kind_example The template file we should use for examples. std::string template_index_classes The template file we should we for the class index. std::string template_index_namespaces The template file we should we for the namespace index. std::string template_index_groups The template file we should we for the group index. std::string template_index_files The template file we should we for the file index. std::string template_index_related_pages The template file we should we for the related page index. std::string template_index_examples The template file we should we for the example index. std::string index_classes_title The title for classes in index pages. std::string index_namespaces_title The title for namespaces in index pages. std::string index_groups_title The title for groups in index pages. std::string index_files_title The title for files in index pages. std::string index_related_pages_title The title for relatedPages in index pages. std::string index_examples_title The title for examples in index pages. std::vector< std::string > files_filter The source files allowed in the output? std::vector< folder_category > folders_to_generate Folders we should generate. std::string formulaInlineStart Token for latex formulas inline start. std::string formulaInlineEnd Token for latex formulas inline end. std::string formulaBlockStart Token for latex formulas block start. std::string formulaBlockEnd Token for latex formulas block end. bool replaceUnderscoresInAnchors Replace underscores with hyphens in anchors. Public Attributes Documentation variable output_dir std :: string output_dir ; Where to store the output files? variable debug_template_json bool debug_template_json { false }; Generate extra JSON for each rendered template. variable use_folders bool use_folders { true }; Put all files into categorized folders. variable index_in_folders bool index_in_folders { false }; Put index files into the respective subdirectories. (Hugo/Learn) needs that variable main_page_in_root bool main_page_in_root { false }; Main page should be located in the root directory. variable main_page_name std :: string main_page_name { \"indexpage\" }; Name of the mainpage / indexpage. variable base_url std :: string base_url { \"\" }; The base URL to prepend all links with. variable file_extension std :: string file_extension { \"md\" }; The extension for markdown files. variable link_suffix std :: string link_suffix { \".md\" }; The suffix to end links with. variable sort bool sort { false }; Sort symbols alphabetically. variable copy_images bool copy_images { true }; Copy images from the Doxygen xml dir. variable images_folder std :: string images_folder { \"images\" }; Where to copy images. variable link_lowercase bool link_lowercase { false }; Convert all refids and folder names to lowercase. variable link_and_inline_code_as_html bool link_and_inline_code_as_html { false }; Output links/code as / tags instead of Markdown. variable folder_groups_name std :: string folder_groups_name { \"modules\" }; The modules folder name. variable folder_classes_name std :: string folder_classes_name { \"classes\" }; The classes folder name. variable folder_files_name std :: string folder_files_name { \"files\" }; The files folder name. variable folder_related_pages_name std :: string folder_related_pages_name { \"pages\" }; The pages folder name. variable folder_namespaces_name std :: string folder_namespaces_name { \"namespaces\" }; The namespaces folder name. variable folder_examples_name std :: string folder_examples_name { \"examples\" }; The examples folder name. variable index_groups_name std :: string index_groups_name { \"index_groups\" }; The groups index file name. variable index_classes_name std :: string index_classes_name { \"index_classes\" }; The classes index file name. variable index_files_name std :: string index_files_name { \"index_files\" }; The files index file name. variable index_related_pages_name std :: string index_related_pages_name { \"index_pages\" }; The relatedPages index file name. variable index_namespaces_name std :: string index_namespaces_name { \"index_namespaces\" }; The namespaces index file name. variable index_examples_name std :: string index_examples_name { \"index_examples\" }; The examples index file name. variable template_kind_class std :: string template_kind_class { \"kind_class\" }; The template file we should use for classes. variable template_kind_struct std :: string template_kind_struct { \"kind_class\" }; The template file we should use for structs. variable template_kind_union std :: string template_kind_union { \"kind_class\" }; The template file we should use for unions. variable template_kind_interface std :: string template_kind_interface { \"kind_class\" }; The template file we should use for interfaces. variable template_kind_java_enum std :: string template_kind_java_enum { \"kind_class\" }; The template file we should use for java enums. variable template_kind_namespace std :: string template_kind_namespace { \"kind_nonclass\" }; The template file we should use for namespaces. variable template_kind_group std :: string template_kind_group { \"kind_nonclass\" }; The template file we should use for groups. variable template_kind_file std :: string template_kind_file { \"kind_file\" }; The template file we should use for files. variable template_kind_dir std :: string template_kind_dir { \"kind_file\" }; The template file we should use for dirs. variable template_kind_page std :: string template_kind_page { \"kind_page\" }; The template file we should use for pages. variable template_kind_example std :: string template_kind_example { \"kind_page\" }; The template file we should use for examples. variable template_index_classes std :: string template_index_classes { \"index_classes\" }; The template file we should we for the class index. variable template_index_namespaces std :: string template_index_namespaces { \"index_namespaces\" }; The template file we should we for the namespace index. variable template_index_groups std :: string template_index_groups { \"index_groups\" }; The template file we should we for the group index. variable template_index_files std :: string template_index_files { \"index_files\" }; The template file we should we for the file index. variable template_index_related_pages std :: string template_index_related_pages { \"index_pages\" }; The template file we should we for the related page index. variable template_index_examples std :: string template_index_examples { \"index_examples\" }; The template file we should we for the example index. variable index_classes_title std :: string index_classes_title { \"Classes\" }; The title for classes in index pages. variable index_namespaces_title std :: string index_namespaces_title { \"Namespaces\" }; The title for namespaces in index pages. variable index_groups_title std :: string index_groups_title { \"Modules\" }; The title for groups in index pages. variable index_files_title std :: string index_files_title { \"Files\" }; The title for files in index pages. variable index_related_pages_title std :: string index_related_pages_title { \"Pages\" }; The title for relatedPages in index pages. variable index_examples_title std :: string index_examples_title { \"Examples\" }; The title for examples in index pages. variable files_filter std :: vector < std :: string > files_filter {}; The source files allowed in the output? An empty list means all files are allowed variable folders_to_generate std :: vector < folder_category > folders_to_generate { folder_category :: MODULES , folder_category :: CLASSES , folder_category :: FILES , folder_category :: PAGES , folder_category :: NAMESPACES , folder_category :: EXAMPLES , }; Folders we should generate. variable formulaInlineStart std :: string formulaInlineStart { \" \\\\ (\" }; Token for latex formulas inline start. variable formulaInlineEnd std :: string formulaInlineEnd { \" \\\\ )\" }; Token for latex formulas inline end. variable formulaBlockStart std :: string formulaBlockStart { \" \\\\ [\" }; Token for latex formulas block start. variable formulaBlockEnd std :: string formulaBlockEnd { \" \\\\ ]\" }; Token for latex formulas block end. variable replaceUnderscoresInAnchors bool replaceUnderscoresInAnchors { true }; Replace underscores with hyphens in anchors. Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook::config"},{"location":"reference/classes/structdoxybook_1_1config/#doxybookconfig","text":"Configuration for the doxygen and generator classes. #include <config.hpp>","title":"doxybook::config"},{"location":"reference/classes/structdoxybook_1_1config/#public-attributes","text":"Name std::string output_dir Where to store the output files? bool debug_template_json Generate extra JSON for each rendered template. bool use_folders Put all files into categorized folders. bool index_in_folders Put index files into the respective subdirectories. bool main_page_in_root Main page should be located in the root directory. std::string main_page_name Name of the mainpage / indexpage. std::string base_url The base URL to prepend all links with. std::string file_extension The extension for markdown files. std::string link_suffix The suffix to end links with. bool sort Sort symbols alphabetically. bool copy_images Copy images from the Doxygen xml dir. std::string images_folder Where to copy images. bool link_lowercase Convert all refids and folder names to lowercase. bool link_and_inline_code_as_html Output links/code as / tags instead of Markdown. std::string folder_groups_name The modules folder name. std::string folder_classes_name The classes folder name. std::string folder_files_name The files folder name. std::string folder_related_pages_name The pages folder name. std::string folder_namespaces_name The namespaces folder name. std::string folder_examples_name The examples folder name. std::string index_groups_name The groups index file name. std::string index_classes_name The classes index file name. std::string index_files_name The files index file name. std::string index_related_pages_name The relatedPages index file name. std::string index_namespaces_name The namespaces index file name. std::string index_examples_name The examples index file name. std::string template_kind_class The template file we should use for classes. std::string template_kind_struct The template file we should use for structs. std::string template_kind_union The template file we should use for unions. std::string template_kind_interface The template file we should use for interfaces. std::string template_kind_java_enum The template file we should use for java enums. std::string template_kind_namespace The template file we should use for namespaces. std::string template_kind_group The template file we should use for groups. std::string template_kind_file The template file we should use for files. std::string template_kind_dir The template file we should use for dirs. std::string template_kind_page The template file we should use for pages. std::string template_kind_example The template file we should use for examples. std::string template_index_classes The template file we should we for the class index. std::string template_index_namespaces The template file we should we for the namespace index. std::string template_index_groups The template file we should we for the group index. std::string template_index_files The template file we should we for the file index. std::string template_index_related_pages The template file we should we for the related page index. std::string template_index_examples The template file we should we for the example index. std::string index_classes_title The title for classes in index pages. std::string index_namespaces_title The title for namespaces in index pages. std::string index_groups_title The title for groups in index pages. std::string index_files_title The title for files in index pages. std::string index_related_pages_title The title for relatedPages in index pages. std::string index_examples_title The title for examples in index pages. std::vector< std::string > files_filter The source files allowed in the output? std::vector< folder_category > folders_to_generate Folders we should generate. std::string formulaInlineStart Token for latex formulas inline start. std::string formulaInlineEnd Token for latex formulas inline end. std::string formulaBlockStart Token for latex formulas block start. std::string formulaBlockEnd Token for latex formulas block end. bool replaceUnderscoresInAnchors Replace underscores with hyphens in anchors.","title":"Public Attributes"},{"location":"reference/classes/structdoxybook_1_1config/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"reference/classes/structdoxybook_1_1config/#variable-output_dir","text":"std :: string output_dir ; Where to store the output files?","title":"variable output_dir"},{"location":"reference/classes/structdoxybook_1_1config/#variable-debug_template_json","text":"bool debug_template_json { false }; Generate extra JSON for each rendered template.","title":"variable debug_template_json"},{"location":"reference/classes/structdoxybook_1_1config/#variable-use_folders","text":"bool use_folders { true }; Put all files into categorized folders.","title":"variable use_folders"},{"location":"reference/classes/structdoxybook_1_1config/#variable-index_in_folders","text":"bool index_in_folders { false }; Put index files into the respective subdirectories. (Hugo/Learn) needs that","title":"variable index_in_folders"},{"location":"reference/classes/structdoxybook_1_1config/#variable-main_page_in_root","text":"bool main_page_in_root { false }; Main page should be located in the root directory.","title":"variable main_page_in_root"},{"location":"reference/classes/structdoxybook_1_1config/#variable-main_page_name","text":"std :: string main_page_name { \"indexpage\" }; Name of the mainpage / indexpage.","title":"variable main_page_name"},{"location":"reference/classes/structdoxybook_1_1config/#variable-base_url","text":"std :: string base_url { \"\" }; The base URL to prepend all links with.","title":"variable base_url"},{"location":"reference/classes/structdoxybook_1_1config/#variable-file_extension","text":"std :: string file_extension { \"md\" }; The extension for markdown files.","title":"variable file_extension"},{"location":"reference/classes/structdoxybook_1_1config/#variable-link_suffix","text":"std :: string link_suffix { \".md\" }; The suffix to end links with.","title":"variable link_suffix"},{"location":"reference/classes/structdoxybook_1_1config/#variable-sort","text":"bool sort { false }; Sort symbols alphabetically.","title":"variable sort"},{"location":"reference/classes/structdoxybook_1_1config/#variable-copy_images","text":"bool copy_images { true }; Copy images from the Doxygen xml dir.","title":"variable copy_images"},{"location":"reference/classes/structdoxybook_1_1config/#variable-images_folder","text":"std :: string images_folder { \"images\" }; Where to copy images.","title":"variable images_folder"},{"location":"reference/classes/structdoxybook_1_1config/#variable-link_lowercase","text":"bool link_lowercase { false }; Convert all refids and folder names to lowercase.","title":"variable link_lowercase"},{"location":"reference/classes/structdoxybook_1_1config/#variable-link_and_inline_code_as_html","text":"bool link_and_inline_code_as_html { false }; Output links/code as / tags instead of Markdown.","title":"variable link_and_inline_code_as_html"},{"location":"reference/classes/structdoxybook_1_1config/#variable-folder_groups_name","text":"std :: string folder_groups_name { \"modules\" }; The modules folder name.","title":"variable folder_groups_name"},{"location":"reference/classes/structdoxybook_1_1config/#variable-folder_classes_name","text":"std :: string folder_classes_name { \"classes\" }; The classes folder name.","title":"variable folder_classes_name"},{"location":"reference/classes/structdoxybook_1_1config/#variable-folder_files_name","text":"std :: string folder_files_name { \"files\" }; The files folder name.","title":"variable folder_files_name"},{"location":"reference/classes/structdoxybook_1_1config/#variable-folder_related_pages_name","text":"std :: string folder_related_pages_name { \"pages\" }; The pages folder name.","title":"variable folder_related_pages_name"},{"location":"reference/classes/structdoxybook_1_1config/#variable-folder_namespaces_name","text":"std :: string folder_namespaces_name { \"namespaces\" }; The namespaces folder name.","title":"variable folder_namespaces_name"},{"location":"reference/classes/structdoxybook_1_1config/#variable-folder_examples_name","text":"std :: string folder_examples_name { \"examples\" }; The examples folder name.","title":"variable folder_examples_name"},{"location":"reference/classes/structdoxybook_1_1config/#variable-index_groups_name","text":"std :: string index_groups_name { \"index_groups\" }; The groups index file name.","title":"variable index_groups_name"},{"location":"reference/classes/structdoxybook_1_1config/#variable-index_classes_name","text":"std :: string index_classes_name { \"index_classes\" }; The classes index file name.","title":"variable index_classes_name"},{"location":"reference/classes/structdoxybook_1_1config/#variable-index_files_name","text":"std :: string index_files_name { \"index_files\" }; The files index file name.","title":"variable index_files_name"},{"location":"reference/classes/structdoxybook_1_1config/#variable-index_related_pages_name","text":"std :: string index_related_pages_name { \"index_pages\" }; The relatedPages index file name.","title":"variable index_related_pages_name"},{"location":"reference/classes/structdoxybook_1_1config/#variable-index_namespaces_name","text":"std :: string index_namespaces_name { \"index_namespaces\" }; The namespaces index file name.","title":"variable index_namespaces_name"},{"location":"reference/classes/structdoxybook_1_1config/#variable-index_examples_name","text":"std :: string index_examples_name { \"index_examples\" }; The examples index file name.","title":"variable index_examples_name"},{"location":"reference/classes/structdoxybook_1_1config/#variable-template_kind_class","text":"std :: string template_kind_class { \"kind_class\" }; The template file we should use for classes.","title":"variable template_kind_class"},{"location":"reference/classes/structdoxybook_1_1config/#variable-template_kind_struct","text":"std :: string template_kind_struct { \"kind_class\" }; The template file we should use for structs.","title":"variable template_kind_struct"},{"location":"reference/classes/structdoxybook_1_1config/#variable-template_kind_union","text":"std :: string template_kind_union { \"kind_class\" }; The template file we should use for unions.","title":"variable template_kind_union"},{"location":"reference/classes/structdoxybook_1_1config/#variable-template_kind_interface","text":"std :: string template_kind_interface { \"kind_class\" }; The template file we should use for interfaces.","title":"variable template_kind_interface"},{"location":"reference/classes/structdoxybook_1_1config/#variable-template_kind_java_enum","text":"std :: string template_kind_java_enum { \"kind_class\" }; The template file we should use for java enums.","title":"variable template_kind_java_enum"},{"location":"reference/classes/structdoxybook_1_1config/#variable-template_kind_namespace","text":"std :: string template_kind_namespace { \"kind_nonclass\" }; The template file we should use for namespaces.","title":"variable template_kind_namespace"},{"location":"reference/classes/structdoxybook_1_1config/#variable-template_kind_group","text":"std :: string template_kind_group { \"kind_nonclass\" }; The template file we should use for groups.","title":"variable template_kind_group"},{"location":"reference/classes/structdoxybook_1_1config/#variable-template_kind_file","text":"std :: string template_kind_file { \"kind_file\" }; The template file we should use for files.","title":"variable template_kind_file"},{"location":"reference/classes/structdoxybook_1_1config/#variable-template_kind_dir","text":"std :: string template_kind_dir { \"kind_file\" }; The template file we should use for dirs.","title":"variable template_kind_dir"},{"location":"reference/classes/structdoxybook_1_1config/#variable-template_kind_page","text":"std :: string template_kind_page { \"kind_page\" }; The template file we should use for pages.","title":"variable template_kind_page"},{"location":"reference/classes/structdoxybook_1_1config/#variable-template_kind_example","text":"std :: string template_kind_example { \"kind_page\" }; The template file we should use for examples.","title":"variable template_kind_example"},{"location":"reference/classes/structdoxybook_1_1config/#variable-template_index_classes","text":"std :: string template_index_classes { \"index_classes\" }; The template file we should we for the class index.","title":"variable template_index_classes"},{"location":"reference/classes/structdoxybook_1_1config/#variable-template_index_namespaces","text":"std :: string template_index_namespaces { \"index_namespaces\" }; The template file we should we for the namespace index.","title":"variable template_index_namespaces"},{"location":"reference/classes/structdoxybook_1_1config/#variable-template_index_groups","text":"std :: string template_index_groups { \"index_groups\" }; The template file we should we for the group index.","title":"variable template_index_groups"},{"location":"reference/classes/structdoxybook_1_1config/#variable-template_index_files","text":"std :: string template_index_files { \"index_files\" }; The template file we should we for the file index.","title":"variable template_index_files"},{"location":"reference/classes/structdoxybook_1_1config/#variable-template_index_related_pages","text":"std :: string template_index_related_pages { \"index_pages\" }; The template file we should we for the related page index.","title":"variable template_index_related_pages"},{"location":"reference/classes/structdoxybook_1_1config/#variable-template_index_examples","text":"std :: string template_index_examples { \"index_examples\" }; The template file we should we for the example index.","title":"variable template_index_examples"},{"location":"reference/classes/structdoxybook_1_1config/#variable-index_classes_title","text":"std :: string index_classes_title { \"Classes\" }; The title for classes in index pages.","title":"variable index_classes_title"},{"location":"reference/classes/structdoxybook_1_1config/#variable-index_namespaces_title","text":"std :: string index_namespaces_title { \"Namespaces\" }; The title for namespaces in index pages.","title":"variable index_namespaces_title"},{"location":"reference/classes/structdoxybook_1_1config/#variable-index_groups_title","text":"std :: string index_groups_title { \"Modules\" }; The title for groups in index pages.","title":"variable index_groups_title"},{"location":"reference/classes/structdoxybook_1_1config/#variable-index_files_title","text":"std :: string index_files_title { \"Files\" }; The title for files in index pages.","title":"variable index_files_title"},{"location":"reference/classes/structdoxybook_1_1config/#variable-index_related_pages_title","text":"std :: string index_related_pages_title { \"Pages\" }; The title for relatedPages in index pages.","title":"variable index_related_pages_title"},{"location":"reference/classes/structdoxybook_1_1config/#variable-index_examples_title","text":"std :: string index_examples_title { \"Examples\" }; The title for examples in index pages.","title":"variable index_examples_title"},{"location":"reference/classes/structdoxybook_1_1config/#variable-files_filter","text":"std :: vector < std :: string > files_filter {}; The source files allowed in the output? An empty list means all files are allowed","title":"variable files_filter"},{"location":"reference/classes/structdoxybook_1_1config/#variable-folders_to_generate","text":"std :: vector < folder_category > folders_to_generate { folder_category :: MODULES , folder_category :: CLASSES , folder_category :: FILES , folder_category :: PAGES , folder_category :: NAMESPACES , folder_category :: EXAMPLES , }; Folders we should generate.","title":"variable folders_to_generate"},{"location":"reference/classes/structdoxybook_1_1config/#variable-formulainlinestart","text":"std :: string formulaInlineStart { \" \\\\ (\" }; Token for latex formulas inline start.","title":"variable formulaInlineStart"},{"location":"reference/classes/structdoxybook_1_1config/#variable-formulainlineend","text":"std :: string formulaInlineEnd { \" \\\\ )\" }; Token for latex formulas inline end.","title":"variable formulaInlineEnd"},{"location":"reference/classes/structdoxybook_1_1config/#variable-formulablockstart","text":"std :: string formulaBlockStart { \" \\\\ [\" }; Token for latex formulas block start.","title":"variable formulaBlockStart"},{"location":"reference/classes/structdoxybook_1_1config/#variable-formulablockend","text":"std :: string formulaBlockEnd { \" \\\\ ]\" }; Token for latex formulas block end.","title":"variable formulaBlockEnd"},{"location":"reference/classes/structdoxybook_1_1config/#variable-replaceunderscoresinanchors","text":"bool replaceUnderscoresInAnchors { true }; Replace underscores with hyphens in anchors. Updated on 2022-11-15 at 04:08:09 +0000","title":"variable replaceUnderscoresInAnchors"},{"location":"reference/classes/structdoxybook_1_1default__template/","text":"doxybook::default_template Describe the default template for a page. #include <default_templates.hpp> Public Attributes Name std::string src The template source. std::vector< std::string > dependencies Files on which the template depends. Public Attributes Documentation variable src std :: string src ; The template source. variable dependencies std :: vector < std :: string > dependencies ; Files on which the template depends. Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook::default_template"},{"location":"reference/classes/structdoxybook_1_1default__template/#doxybookdefault_template","text":"Describe the default template for a page. #include <default_templates.hpp>","title":"doxybook::default_template"},{"location":"reference/classes/structdoxybook_1_1default__template/#public-attributes","text":"Name std::string src The template source. std::vector< std::string > dependencies Files on which the template depends.","title":"Public Attributes"},{"location":"reference/classes/structdoxybook_1_1default__template/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"reference/classes/structdoxybook_1_1default__template/#variable-src","text":"std :: string src ; The template source.","title":"variable src"},{"location":"reference/classes/structdoxybook_1_1default__template/#variable-dependencies","text":"std :: vector < std :: string > dependencies ; Files on which the template depends. Updated on 2022-11-15 at 04:08:09 +0000","title":"variable dependencies"},{"location":"reference/classes/structdoxybook_1_1generator_1_1summary__section/","text":"doxybook::generator::summary_section A section we should generate. #include <generator.hpp> Public Attributes Name folder_category type The type of the section. filter_set filter The kinds we should use. filter_set skip The kinds we should skip. Public Attributes Documentation variable type folder_category type ; The type of the section. variable filter filter_set filter ; The kinds we should use. variable skip filter_set skip ; The kinds we should skip. Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook::generator::summary_section"},{"location":"reference/classes/structdoxybook_1_1generator_1_1summary__section/#doxybookgeneratorsummary_section","text":"A section we should generate. #include <generator.hpp>","title":"doxybook::generator::summary_section"},{"location":"reference/classes/structdoxybook_1_1generator_1_1summary__section/#public-attributes","text":"Name folder_category type The type of the section. filter_set filter The kinds we should use. filter_set skip The kinds we should skip.","title":"Public Attributes"},{"location":"reference/classes/structdoxybook_1_1generator_1_1summary__section/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"reference/classes/structdoxybook_1_1generator_1_1summary__section/#variable-type","text":"folder_category type ; The type of the section.","title":"variable type"},{"location":"reference/classes/structdoxybook_1_1generator_1_1summary__section/#variable-filter","text":"filter_set filter ; The kinds we should use.","title":"variable filter"},{"location":"reference/classes/structdoxybook_1_1generator_1_1summary__section/#variable-skip","text":"filter_set skip ; The kinds we should skip. Updated on 2022-11-15 at 04:08:09 +0000","title":"variable skip"},{"location":"reference/classes/structdoxybook_1_1node_1_1class__reference/","text":"doxybook::node::class_reference A reference to a class. More... #include <node.hpp> Public Attributes Name std::string name std::string refid visibility prot virtual_category virt node const * ptr Detailed Description struct doxybook :: node :: class_reference ; A reference to a class. These are usually used to represent base and derived classes Public Attributes Documentation variable name std :: string name ; variable refid std :: string refid ; variable prot visibility prot ; variable virt virtual_category virt ; variable ptr node const * ptr { nullptr }; Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook::node::class_reference"},{"location":"reference/classes/structdoxybook_1_1node_1_1class__reference/#doxybooknodeclass_reference","text":"A reference to a class. More... #include <node.hpp>","title":"doxybook::node::class_reference"},{"location":"reference/classes/structdoxybook_1_1node_1_1class__reference/#public-attributes","text":"Name std::string name std::string refid visibility prot virtual_category virt node const * ptr","title":"Public Attributes"},{"location":"reference/classes/structdoxybook_1_1node_1_1class__reference/#detailed-description","text":"struct doxybook :: node :: class_reference ; A reference to a class. These are usually used to represent base and derived classes","title":"Detailed Description"},{"location":"reference/classes/structdoxybook_1_1node_1_1class__reference/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"reference/classes/structdoxybook_1_1node_1_1class__reference/#variable-name","text":"std :: string name ;","title":"variable name"},{"location":"reference/classes/structdoxybook_1_1node_1_1class__reference/#variable-refid","text":"std :: string refid ;","title":"variable refid"},{"location":"reference/classes/structdoxybook_1_1node_1_1class__reference/#variable-prot","text":"visibility prot ;","title":"variable prot"},{"location":"reference/classes/structdoxybook_1_1node_1_1class__reference/#variable-virt","text":"virtual_category virt ;","title":"variable virt"},{"location":"reference/classes/structdoxybook_1_1node_1_1class__reference/#variable-ptr","text":"node const * ptr { nullptr }; Updated on 2022-11-15 at 04:08:09 +0000","title":"variable ptr"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/","text":"doxybook::node::data The data in a doxygen node. #include <node.hpp> Public Attributes Name std::vector< class_reference > base_classes std::string definition std::string args_string std::string initializer std::vector< class_reference > derived_classes bool is_abstract bool is_static bool is_const bool is_explicit bool is_strong bool is_inline bool is_default bool is_deleted bool is_override source_location location std::string details std::string in_body std::string includes std::string type std::string type_plain std::string deprecated std::vector< param > params std::vector< param > template_params std::vector< std::string > see std::vector< std::string > returns std::vector< std::string > authors std::vector< std::string > version std::vector< std::string > since std::vector< std::string > date std::vector< std::string > note std::vector< std::string > warning std::vector< std::string > pre std::vector< std::string > post std::vector< std::string > copyright std::vector< std::string > invariant std::vector< std::string > remark std::vector< std::string > attention std::vector< std::string > par std::vector< std::string > rcs std::vector< std::string > bugs std::vector< std::string > tests std::vector< std::string > todos std::vector< node::parameter_list_item > param_list std::vector< node::parameter_list_item > returns_list std::vector< node::parameter_list_item > template_params_list std::vector< node::parameter_list_item > exceptions_list node const * reimplements std::vector< node const * > reimplemented_by std::string program_listing Public Attributes Documentation variable base_classes std :: vector < class_reference > base_classes ; variable definition std :: string definition ; variable args_string std :: string args_string ; variable initializer std :: string initializer ; variable derived_classes std :: vector < class_reference > derived_classes ; variable is_abstract bool is_abstract { false }; variable is_static bool is_static { false }; variable is_const bool is_const { false }; variable is_explicit bool is_explicit { false }; variable is_strong bool is_strong { false }; variable is_inline bool is_inline { false }; variable is_default bool is_default { false }; variable is_deleted bool is_deleted { false }; variable is_override bool is_override { false }; variable location source_location location ; variable details std :: string details ; variable in_body std :: string in_body ; variable includes std :: string includes ; variable type std :: string type ; variable type_plain std :: string type_plain ; variable deprecated std :: string deprecated ; variable params std :: vector < param > params ; variable template_params std :: vector < param > template_params ; variable see std :: vector < std :: string > see ; variable returns std :: vector < std :: string > returns ; variable authors std :: vector < std :: string > authors ; variable version std :: vector < std :: string > version ; variable since std :: vector < std :: string > since ; variable date std :: vector < std :: string > date ; variable note std :: vector < std :: string > note ; variable warning std :: vector < std :: string > warning ; variable pre std :: vector < std :: string > pre ; variable post std :: vector < std :: string > post ; variable copyright std :: vector < std :: string > copyright ; variable invariant std :: vector < std :: string > invariant ; variable remark std :: vector < std :: string > remark ; variable attention std :: vector < std :: string > attention ; variable par std :: vector < std :: string > par ; variable rcs std :: vector < std :: string > rcs ; variable bugs std :: vector < std :: string > bugs ; variable tests std :: vector < std :: string > tests ; variable todos std :: vector < std :: string > todos ; variable param_list std :: vector < node :: parameter_list_item > param_list ; variable returns_list std :: vector < node :: parameter_list_item > returns_list ; variable template_params_list std :: vector < node :: parameter_list_item > template_params_list ; variable exceptions_list std :: vector < node :: parameter_list_item > exceptions_list ; variable reimplements node const * reimplements { nullptr }; variable reimplemented_by std :: vector < node const * > reimplemented_by ; variable program_listing std :: string program_listing ; Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook::node::data"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#doxybooknodedata","text":"The data in a doxygen node. #include <node.hpp>","title":"doxybook::node::data"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#public-attributes","text":"Name std::vector< class_reference > base_classes std::string definition std::string args_string std::string initializer std::vector< class_reference > derived_classes bool is_abstract bool is_static bool is_const bool is_explicit bool is_strong bool is_inline bool is_default bool is_deleted bool is_override source_location location std::string details std::string in_body std::string includes std::string type std::string type_plain std::string deprecated std::vector< param > params std::vector< param > template_params std::vector< std::string > see std::vector< std::string > returns std::vector< std::string > authors std::vector< std::string > version std::vector< std::string > since std::vector< std::string > date std::vector< std::string > note std::vector< std::string > warning std::vector< std::string > pre std::vector< std::string > post std::vector< std::string > copyright std::vector< std::string > invariant std::vector< std::string > remark std::vector< std::string > attention std::vector< std::string > par std::vector< std::string > rcs std::vector< std::string > bugs std::vector< std::string > tests std::vector< std::string > todos std::vector< node::parameter_list_item > param_list std::vector< node::parameter_list_item > returns_list std::vector< node::parameter_list_item > template_params_list std::vector< node::parameter_list_item > exceptions_list node const * reimplements std::vector< node const * > reimplemented_by std::string program_listing","title":"Public Attributes"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-base_classes","text":"std :: vector < class_reference > base_classes ;","title":"variable base_classes"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-definition","text":"std :: string definition ;","title":"variable definition"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-args_string","text":"std :: string args_string ;","title":"variable args_string"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-initializer","text":"std :: string initializer ;","title":"variable initializer"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-derived_classes","text":"std :: vector < class_reference > derived_classes ;","title":"variable derived_classes"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-is_abstract","text":"bool is_abstract { false };","title":"variable is_abstract"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-is_static","text":"bool is_static { false };","title":"variable is_static"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-is_const","text":"bool is_const { false };","title":"variable is_const"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-is_explicit","text":"bool is_explicit { false };","title":"variable is_explicit"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-is_strong","text":"bool is_strong { false };","title":"variable is_strong"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-is_inline","text":"bool is_inline { false };","title":"variable is_inline"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-is_default","text":"bool is_default { false };","title":"variable is_default"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-is_deleted","text":"bool is_deleted { false };","title":"variable is_deleted"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-is_override","text":"bool is_override { false };","title":"variable is_override"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-location","text":"source_location location ;","title":"variable location"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-details","text":"std :: string details ;","title":"variable details"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-in_body","text":"std :: string in_body ;","title":"variable in_body"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-includes","text":"std :: string includes ;","title":"variable includes"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-type","text":"std :: string type ;","title":"variable type"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-type_plain","text":"std :: string type_plain ;","title":"variable type_plain"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-deprecated","text":"std :: string deprecated ;","title":"variable deprecated"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-params","text":"std :: vector < param > params ;","title":"variable params"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-template_params","text":"std :: vector < param > template_params ;","title":"variable template_params"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-see","text":"std :: vector < std :: string > see ;","title":"variable see"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-returns","text":"std :: vector < std :: string > returns ;","title":"variable returns"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-authors","text":"std :: vector < std :: string > authors ;","title":"variable authors"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-version","text":"std :: vector < std :: string > version ;","title":"variable version"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-since","text":"std :: vector < std :: string > since ;","title":"variable since"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-date","text":"std :: vector < std :: string > date ;","title":"variable date"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-note","text":"std :: vector < std :: string > note ;","title":"variable note"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-warning","text":"std :: vector < std :: string > warning ;","title":"variable warning"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-pre","text":"std :: vector < std :: string > pre ;","title":"variable pre"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-post","text":"std :: vector < std :: string > post ;","title":"variable post"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-copyright","text":"std :: vector < std :: string > copyright ;","title":"variable copyright"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-invariant","text":"std :: vector < std :: string > invariant ;","title":"variable invariant"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-remark","text":"std :: vector < std :: string > remark ;","title":"variable remark"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-attention","text":"std :: vector < std :: string > attention ;","title":"variable attention"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-par","text":"std :: vector < std :: string > par ;","title":"variable par"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-rcs","text":"std :: vector < std :: string > rcs ;","title":"variable rcs"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-bugs","text":"std :: vector < std :: string > bugs ;","title":"variable bugs"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-tests","text":"std :: vector < std :: string > tests ;","title":"variable tests"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-todos","text":"std :: vector < std :: string > todos ;","title":"variable todos"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-param_list","text":"std :: vector < node :: parameter_list_item > param_list ;","title":"variable param_list"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-returns_list","text":"std :: vector < node :: parameter_list_item > returns_list ;","title":"variable returns_list"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-template_params_list","text":"std :: vector < node :: parameter_list_item > template_params_list ;","title":"variable template_params_list"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-exceptions_list","text":"std :: vector < node :: parameter_list_item > exceptions_list ;","title":"variable exceptions_list"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-reimplements","text":"node const * reimplements { nullptr };","title":"variable reimplements"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-reimplemented_by","text":"std :: vector < node const * > reimplemented_by ;","title":"variable reimplemented_by"},{"location":"reference/classes/structdoxybook_1_1node_1_1data/#variable-program_listing","text":"std :: string program_listing ; Updated on 2022-11-15 at 04:08:09 +0000","title":"variable program_listing"},{"location":"reference/classes/structdoxybook_1_1node_1_1param/","text":"doxybook::node::param A parameter. More... #include <node.hpp> Public Attributes Name std::string type std::string type_plain std::string name std::string def_val std::string def_val_plain Detailed Description struct doxybook :: node :: param ; A parameter. This is used for parameters and template parameters. Public Attributes Documentation variable type std :: string type ; variable type_plain std :: string type_plain ; variable name std :: string name ; variable def_val std :: string def_val ; variable def_val_plain std :: string def_val_plain ; Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook::node::param"},{"location":"reference/classes/structdoxybook_1_1node_1_1param/#doxybooknodeparam","text":"A parameter. More... #include <node.hpp>","title":"doxybook::node::param"},{"location":"reference/classes/structdoxybook_1_1node_1_1param/#public-attributes","text":"Name std::string type std::string type_plain std::string name std::string def_val std::string def_val_plain","title":"Public Attributes"},{"location":"reference/classes/structdoxybook_1_1node_1_1param/#detailed-description","text":"struct doxybook :: node :: param ; A parameter. This is used for parameters and template parameters.","title":"Detailed Description"},{"location":"reference/classes/structdoxybook_1_1node_1_1param/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"reference/classes/structdoxybook_1_1node_1_1param/#variable-type","text":"std :: string type ;","title":"variable type"},{"location":"reference/classes/structdoxybook_1_1node_1_1param/#variable-type_plain","text":"std :: string type_plain ;","title":"variable type_plain"},{"location":"reference/classes/structdoxybook_1_1node_1_1param/#variable-name","text":"std :: string name ;","title":"variable name"},{"location":"reference/classes/structdoxybook_1_1node_1_1param/#variable-def_val","text":"std :: string def_val ;","title":"variable def_val"},{"location":"reference/classes/structdoxybook_1_1node_1_1param/#variable-def_val_plain","text":"std :: string def_val_plain ; Updated on 2022-11-15 at 04:08:09 +0000","title":"variable def_val_plain"},{"location":"reference/classes/structdoxybook_1_1node_1_1parameter__list__item/","text":"doxybook::node::parameter_list_item An item in a list of parameters. More... #include <node.hpp> Public Attributes Name std::string name std::string text Detailed Description struct doxybook :: node :: parameter_list_item ; An item in a list of parameters. These could be used for parameters, return values, template parameters, and exceptions. Public Attributes Documentation variable name std :: string name ; variable text std :: string text ; Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook::node::parameter_list_item"},{"location":"reference/classes/structdoxybook_1_1node_1_1parameter__list__item/#doxybooknodeparameter_list_item","text":"An item in a list of parameters. More... #include <node.hpp>","title":"doxybook::node::parameter_list_item"},{"location":"reference/classes/structdoxybook_1_1node_1_1parameter__list__item/#public-attributes","text":"Name std::string name std::string text","title":"Public Attributes"},{"location":"reference/classes/structdoxybook_1_1node_1_1parameter__list__item/#detailed-description","text":"struct doxybook :: node :: parameter_list_item ; An item in a list of parameters. These could be used for parameters, return values, template parameters, and exceptions.","title":"Detailed Description"},{"location":"reference/classes/structdoxybook_1_1node_1_1parameter__list__item/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"reference/classes/structdoxybook_1_1node_1_1parameter__list__item/#variable-name","text":"std :: string name ;","title":"variable name"},{"location":"reference/classes/structdoxybook_1_1node_1_1parameter__list__item/#variable-text","text":"std :: string text ; Updated on 2022-11-15 at 04:08:09 +0000","title":"variable text"},{"location":"reference/classes/structdoxybook_1_1node_1_1source__location/","text":"doxybook::node::source_location Source code location. #include <node.hpp> Public Attributes Name std::string file int line int column std::string body_file int body_start int body_end Public Attributes Documentation variable file std :: string file ; variable line int line { 0 }; variable column int column { 0 }; variable body_file std :: string body_file ; variable body_start int body_start { 0 }; variable body_end int body_end { 0 }; Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook::node::source_location"},{"location":"reference/classes/structdoxybook_1_1node_1_1source__location/#doxybooknodesource_location","text":"Source code location. #include <node.hpp>","title":"doxybook::node::source_location"},{"location":"reference/classes/structdoxybook_1_1node_1_1source__location/#public-attributes","text":"Name std::string file int line int column std::string body_file int body_start int body_end","title":"Public Attributes"},{"location":"reference/classes/structdoxybook_1_1node_1_1source__location/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"reference/classes/structdoxybook_1_1node_1_1source__location/#variable-file","text":"std :: string file ;","title":"variable file"},{"location":"reference/classes/structdoxybook_1_1node_1_1source__location/#variable-line","text":"int line { 0 };","title":"variable line"},{"location":"reference/classes/structdoxybook_1_1node_1_1source__location/#variable-column","text":"int column { 0 };","title":"variable column"},{"location":"reference/classes/structdoxybook_1_1node_1_1source__location/#variable-body_file","text":"std :: string body_file ;","title":"variable body_file"},{"location":"reference/classes/structdoxybook_1_1node_1_1source__location/#variable-body_start","text":"int body_start { 0 };","title":"variable body_start"},{"location":"reference/classes/structdoxybook_1_1node_1_1source__location/#variable-body_end","text":"int body_end { 0 }; Updated on 2022-11-15 at 04:08:09 +0000","title":"variable body_end"},{"location":"reference/classes/structdoxybook_1_1text__markdown__printer_1_1list__data/","text":"doxybook::text_markdown_printer::list_data Public Attributes Name int counter bool ordered Public Attributes Documentation variable counter int counter { 0 }; variable ordered bool ordered { false }; Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook::text_markdown_printer::list_data"},{"location":"reference/classes/structdoxybook_1_1text__markdown__printer_1_1list__data/#doxybooktext_markdown_printerlist_data","text":"","title":"doxybook::text_markdown_printer::list_data"},{"location":"reference/classes/structdoxybook_1_1text__markdown__printer_1_1list__data/#public-attributes","text":"Name int counter bool ordered","title":"Public Attributes"},{"location":"reference/classes/structdoxybook_1_1text__markdown__printer_1_1list__data/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"reference/classes/structdoxybook_1_1text__markdown__printer_1_1list__data/#variable-counter","text":"int counter { 0 };","title":"variable counter"},{"location":"reference/classes/structdoxybook_1_1text__markdown__printer_1_1list__data/#variable-ordered","text":"bool ordered { false }; Updated on 2022-11-15 at 04:08:09 +0000","title":"variable ordered"},{"location":"reference/classes/structdoxybook_1_1text__markdown__printer_1_1print__data/","text":"doxybook::text_markdown_printer::print_data Public Attributes Name std::stringstream ss int indent std::list< list_data > lists bool quote bool eol bool table_header bool in_computer_output bool valid_link Public Attributes Documentation variable ss std :: stringstream ss ; variable indent int indent { 0 }; variable lists std :: list < list_data > lists ; variable quote bool quote { false }; variable eol bool eol { false }; variable table_header bool table_header { false }; variable in_computer_output bool in_computer_output { false }; variable valid_link bool valid_link { false }; Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook::text_markdown_printer::print_data"},{"location":"reference/classes/structdoxybook_1_1text__markdown__printer_1_1print__data/#doxybooktext_markdown_printerprint_data","text":"","title":"doxybook::text_markdown_printer::print_data"},{"location":"reference/classes/structdoxybook_1_1text__markdown__printer_1_1print__data/#public-attributes","text":"Name std::stringstream ss int indent std::list< list_data > lists bool quote bool eol bool table_header bool in_computer_output bool valid_link","title":"Public Attributes"},{"location":"reference/classes/structdoxybook_1_1text__markdown__printer_1_1print__data/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"reference/classes/structdoxybook_1_1text__markdown__printer_1_1print__data/#variable-ss","text":"std :: stringstream ss ;","title":"variable ss"},{"location":"reference/classes/structdoxybook_1_1text__markdown__printer_1_1print__data/#variable-indent","text":"int indent { 0 };","title":"variable indent"},{"location":"reference/classes/structdoxybook_1_1text__markdown__printer_1_1print__data/#variable-lists","text":"std :: list < list_data > lists ;","title":"variable lists"},{"location":"reference/classes/structdoxybook_1_1text__markdown__printer_1_1print__data/#variable-quote","text":"bool quote { false };","title":"variable quote"},{"location":"reference/classes/structdoxybook_1_1text__markdown__printer_1_1print__data/#variable-eol","text":"bool eol { false };","title":"variable eol"},{"location":"reference/classes/structdoxybook_1_1text__markdown__printer_1_1print__data/#variable-table_header","text":"bool table_header { false };","title":"variable table_header"},{"location":"reference/classes/structdoxybook_1_1text__markdown__printer_1_1print__data/#variable-in_computer_output","text":"bool in_computer_output { false };","title":"variable in_computer_output"},{"location":"reference/classes/structdoxybook_1_1text__markdown__printer_1_1print__data/#variable-valid_link","text":"bool valid_link { false }; Updated on 2022-11-15 at 04:08:09 +0000","title":"variable valid_link"},{"location":"reference/classes/structdoxybook_1_1xml__text__parser_1_1node/","text":"doxybook::xml_text_parser::node A parsed xml node. #include <xml_text_parser.hpp> Public Types Name enum class type { UNKNOWN = -1, TEXT = 0, PARA, PARAS, BOLD, EMPHASIS, STRIKE, HRULER, IMAGE, ULINK, REF, COMPUTEROUTPUT, LISTITEM, SIMPLESEC, ITEMIZEDLIST, VARIABLELIST, ORDEREDLIST, PARAMETERLIST, PARAMETERNAME, PARAMETERITEM, PARAMETERDESCRIPTION, PARAMETERNAMELIST, XREFSECT, XREFTITLE, XREFDESCRIPTION, PROGRAMLISTING, CODELINE, TERM, VARLISTENTRY, ANCHOR, SP, HIGHTLIGHT, SECT1, SECT2, SECT3, SECT4, SECT5, SECT6, TITLE, SUPERSCRIPT, NONBREAKSPACE, TABLE, TABLE_ROW, TABLE_CELL, VERBATIM, SQUO, NDASH, MDASH, LINEBREAK, ONLYFOR, FORMULA, BLOCKQUOTE} The node type. Public Attributes Name type type The node type. std::vector< node > children The child nodes. std::string data The node data as a string. std::string extra Extra data. Public Types Documentation enum type Enumerator Value Description UNKNOWN -1 TEXT 0 PARA PARAS BOLD EMPHASIS STRIKE HRULER IMAGE ULINK REF COMPUTEROUTPUT LISTITEM SIMPLESEC ITEMIZEDLIST VARIABLELIST ORDEREDLIST PARAMETERLIST PARAMETERNAME PARAMETERITEM PARAMETERDESCRIPTION PARAMETERNAMELIST XREFSECT XREFTITLE XREFDESCRIPTION PROGRAMLISTING CODELINE TERM VARLISTENTRY ANCHOR SP HIGHTLIGHT SECT1 SECT2 SECT3 SECT4 SECT5 SECT6 TITLE SUPERSCRIPT NONBREAKSPACE TABLE TABLE_ROW TABLE_CELL VERBATIM SQUO NDASH MDASH LINEBREAK ONLYFOR FORMULA BLOCKQUOTE The node type. Public Attributes Documentation variable type type type { type :: UNKNOWN }; The node type. variable children std :: vector < node > children ; The child nodes. variable data std :: string data ; The node data as a string. variable extra std :: string extra ; Extra data. Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook::xml_text_parser::node"},{"location":"reference/classes/structdoxybook_1_1xml__text__parser_1_1node/#doxybookxml_text_parsernode","text":"A parsed xml node. #include <xml_text_parser.hpp>","title":"doxybook::xml_text_parser::node"},{"location":"reference/classes/structdoxybook_1_1xml__text__parser_1_1node/#public-types","text":"Name enum class type { UNKNOWN = -1, TEXT = 0, PARA, PARAS, BOLD, EMPHASIS, STRIKE, HRULER, IMAGE, ULINK, REF, COMPUTEROUTPUT, LISTITEM, SIMPLESEC, ITEMIZEDLIST, VARIABLELIST, ORDEREDLIST, PARAMETERLIST, PARAMETERNAME, PARAMETERITEM, PARAMETERDESCRIPTION, PARAMETERNAMELIST, XREFSECT, XREFTITLE, XREFDESCRIPTION, PROGRAMLISTING, CODELINE, TERM, VARLISTENTRY, ANCHOR, SP, HIGHTLIGHT, SECT1, SECT2, SECT3, SECT4, SECT5, SECT6, TITLE, SUPERSCRIPT, NONBREAKSPACE, TABLE, TABLE_ROW, TABLE_CELL, VERBATIM, SQUO, NDASH, MDASH, LINEBREAK, ONLYFOR, FORMULA, BLOCKQUOTE} The node type.","title":"Public Types"},{"location":"reference/classes/structdoxybook_1_1xml__text__parser_1_1node/#public-attributes","text":"Name type type The node type. std::vector< node > children The child nodes. std::string data The node data as a string. std::string extra Extra data.","title":"Public Attributes"},{"location":"reference/classes/structdoxybook_1_1xml__text__parser_1_1node/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"reference/classes/structdoxybook_1_1xml__text__parser_1_1node/#enum-type","text":"Enumerator Value Description UNKNOWN -1 TEXT 0 PARA PARAS BOLD EMPHASIS STRIKE HRULER IMAGE ULINK REF COMPUTEROUTPUT LISTITEM SIMPLESEC ITEMIZEDLIST VARIABLELIST ORDEREDLIST PARAMETERLIST PARAMETERNAME PARAMETERITEM PARAMETERDESCRIPTION PARAMETERNAMELIST XREFSECT XREFTITLE XREFDESCRIPTION PROGRAMLISTING CODELINE TERM VARLISTENTRY ANCHOR SP HIGHTLIGHT SECT1 SECT2 SECT3 SECT4 SECT5 SECT6 TITLE SUPERSCRIPT NONBREAKSPACE TABLE TABLE_ROW TABLE_CELL VERBATIM SQUO NDASH MDASH LINEBREAK ONLYFOR FORMULA BLOCKQUOTE The node type.","title":"enum type"},{"location":"reference/classes/structdoxybook_1_1xml__text__parser_1_1node/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"reference/classes/structdoxybook_1_1xml__text__parser_1_1node/#variable-type","text":"type type { type :: UNKNOWN }; The node type.","title":"variable type"},{"location":"reference/classes/structdoxybook_1_1xml__text__parser_1_1node/#variable-children","text":"std :: vector < node > children ; The child nodes.","title":"variable children"},{"location":"reference/classes/structdoxybook_1_1xml__text__parser_1_1node/#variable-data","text":"std :: string data ; The node data as a string.","title":"variable data"},{"location":"reference/classes/structdoxybook_1_1xml__text__parser_1_1node/#variable-extra","text":"std :: string extra ; Extra data. Updated on 2022-11-15 at 04:08:09 +0000","title":"variable extra"},{"location":"reference/examples/","text":"Examples Updated on 2022-11-15 at 04:08:09 +0000","title":"Examples"},{"location":"reference/examples/#examples","text":"Updated on 2022-11-15 at 04:08:09 +0000","title":"Examples"},{"location":"reference/files/","text":"Files dir doxybook file config.hpp file default_templates.hpp file doxygen.hpp file enums.hpp file exception.hpp file exception_utils.hpp file generator.hpp file json_converter.hpp file node.hpp file path.hpp file renderer.hpp file text_markdown_printer.hpp file text_plain_printer.hpp file text_printer.hpp file utils.hpp file xml.hpp file xml_text_parser.hpp Updated on 2022-11-15 at 04:08:09 +0000","title":"Files"},{"location":"reference/files/#files","text":"dir doxybook file config.hpp file default_templates.hpp file doxygen.hpp file enums.hpp file exception.hpp file exception_utils.hpp file generator.hpp file json_converter.hpp file node.hpp file path.hpp file renderer.hpp file text_markdown_printer.hpp file text_plain_printer.hpp file text_printer.hpp file utils.hpp file xml.hpp file xml_text_parser.hpp Updated on 2022-11-15 at 04:08:09 +0000","title":"Files"},{"location":"reference/files/config_8hpp/","text":"doxybook/config.hpp Namespaces Name doxybook Classes Name struct doxybook::config Configuration for the doxygen and generator classes. Source code // // Copyright (c) 2021 Matus Novak (@matusnovak) // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #ifndef DOXYBOOK_CONFIG_HPP #define DOXYBOOK_CONFIG_HPP #include <doxybook/enums.hpp> #include <string> namespace doxybook { struct config { std :: string output_dir ; bool debug_template_json { false }; bool use_folders { true }; bool index_in_folders { false }; bool main_page_in_root { false }; std :: string main_page_name { \"indexpage\" }; std :: string base_url { \"\" }; std :: string file_extension { \"md\" }; std :: string link_suffix { \".md\" }; bool sort { false }; bool copy_images { true }; std :: string images_folder { \"images\" }; bool link_lowercase { false }; bool link_and_inline_code_as_html { false }; std :: string folder_groups_name { \"modules\" }; std :: string folder_classes_name { \"classes\" }; std :: string folder_files_name { \"files\" }; std :: string folder_related_pages_name { \"pages\" }; std :: string folder_namespaces_name { \"namespaces\" }; std :: string folder_examples_name { \"examples\" }; std :: string index_groups_name { \"index_groups\" }; std :: string index_classes_name { \"index_classes\" }; std :: string index_files_name { \"index_files\" }; std :: string index_related_pages_name { \"index_pages\" }; std :: string index_namespaces_name { \"index_namespaces\" }; std :: string index_examples_name { \"index_examples\" }; std :: string template_kind_class { \"kind_class\" }; std :: string template_kind_struct { \"kind_class\" }; std :: string template_kind_union { \"kind_class\" }; std :: string template_kind_interface { \"kind_class\" }; std :: string template_kind_java_enum { \"kind_class\" }; std :: string template_kind_namespace { \"kind_nonclass\" }; std :: string template_kind_group { \"kind_nonclass\" }; std :: string template_kind_file { \"kind_file\" }; std :: string template_kind_dir { \"kind_file\" }; std :: string template_kind_page { \"kind_page\" }; std :: string template_kind_example { \"kind_page\" }; std :: string template_index_classes { \"index_classes\" }; std :: string template_index_namespaces { \"index_namespaces\" }; std :: string template_index_groups { \"index_groups\" }; std :: string template_index_files { \"index_files\" }; std :: string template_index_related_pages { \"index_pages\" }; std :: string template_index_examples { \"index_examples\" }; std :: string index_classes_title { \"Classes\" }; std :: string index_namespaces_title { \"Namespaces\" }; std :: string index_groups_title { \"Modules\" }; std :: string index_files_title { \"Files\" }; std :: string index_related_pages_title { \"Pages\" }; std :: string index_examples_title { \"Examples\" }; std :: vector < std :: string > files_filter {}; std :: vector < folder_category > folders_to_generate { folder_category :: MODULES , folder_category :: CLASSES , folder_category :: FILES , folder_category :: PAGES , folder_category :: NAMESPACES , folder_category :: EXAMPLES , }; std :: string formulaInlineStart { \" \\\\ (\" }; std :: string formulaInlineEnd { \" \\\\ )\" }; std :: string formulaBlockStart { \" \\\\ [\" }; std :: string formulaBlockEnd { \" \\\\ ]\" }; bool replaceUnderscoresInAnchors { true }; }; void load_config ( config & config , std :: string const & path ); void load_config_data ( config & config , std :: string_view src ); void save_config ( config & config , std :: string const & path ); } // namespace doxybook #endif Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook/config.hpp"},{"location":"reference/files/config_8hpp/#doxybookconfighpp","text":"","title":"doxybook/config.hpp"},{"location":"reference/files/config_8hpp/#namespaces","text":"Name doxybook","title":"Namespaces"},{"location":"reference/files/config_8hpp/#classes","text":"Name struct doxybook::config Configuration for the doxygen and generator classes.","title":"Classes"},{"location":"reference/files/config_8hpp/#source-code","text":"// // Copyright (c) 2021 Matus Novak (@matusnovak) // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #ifndef DOXYBOOK_CONFIG_HPP #define DOXYBOOK_CONFIG_HPP #include <doxybook/enums.hpp> #include <string> namespace doxybook { struct config { std :: string output_dir ; bool debug_template_json { false }; bool use_folders { true }; bool index_in_folders { false }; bool main_page_in_root { false }; std :: string main_page_name { \"indexpage\" }; std :: string base_url { \"\" }; std :: string file_extension { \"md\" }; std :: string link_suffix { \".md\" }; bool sort { false }; bool copy_images { true }; std :: string images_folder { \"images\" }; bool link_lowercase { false }; bool link_and_inline_code_as_html { false }; std :: string folder_groups_name { \"modules\" }; std :: string folder_classes_name { \"classes\" }; std :: string folder_files_name { \"files\" }; std :: string folder_related_pages_name { \"pages\" }; std :: string folder_namespaces_name { \"namespaces\" }; std :: string folder_examples_name { \"examples\" }; std :: string index_groups_name { \"index_groups\" }; std :: string index_classes_name { \"index_classes\" }; std :: string index_files_name { \"index_files\" }; std :: string index_related_pages_name { \"index_pages\" }; std :: string index_namespaces_name { \"index_namespaces\" }; std :: string index_examples_name { \"index_examples\" }; std :: string template_kind_class { \"kind_class\" }; std :: string template_kind_struct { \"kind_class\" }; std :: string template_kind_union { \"kind_class\" }; std :: string template_kind_interface { \"kind_class\" }; std :: string template_kind_java_enum { \"kind_class\" }; std :: string template_kind_namespace { \"kind_nonclass\" }; std :: string template_kind_group { \"kind_nonclass\" }; std :: string template_kind_file { \"kind_file\" }; std :: string template_kind_dir { \"kind_file\" }; std :: string template_kind_page { \"kind_page\" }; std :: string template_kind_example { \"kind_page\" }; std :: string template_index_classes { \"index_classes\" }; std :: string template_index_namespaces { \"index_namespaces\" }; std :: string template_index_groups { \"index_groups\" }; std :: string template_index_files { \"index_files\" }; std :: string template_index_related_pages { \"index_pages\" }; std :: string template_index_examples { \"index_examples\" }; std :: string index_classes_title { \"Classes\" }; std :: string index_namespaces_title { \"Namespaces\" }; std :: string index_groups_title { \"Modules\" }; std :: string index_files_title { \"Files\" }; std :: string index_related_pages_title { \"Pages\" }; std :: string index_examples_title { \"Examples\" }; std :: vector < std :: string > files_filter {}; std :: vector < folder_category > folders_to_generate { folder_category :: MODULES , folder_category :: CLASSES , folder_category :: FILES , folder_category :: PAGES , folder_category :: NAMESPACES , folder_category :: EXAMPLES , }; std :: string formulaInlineStart { \" \\\\ (\" }; std :: string formulaInlineEnd { \" \\\\ )\" }; std :: string formulaBlockStart { \" \\\\ [\" }; std :: string formulaBlockEnd { \" \\\\ ]\" }; bool replaceUnderscoresInAnchors { true }; }; void load_config ( config & config , std :: string const & path ); void load_config_data ( config & config , std :: string_view src ); void save_config ( config & config , std :: string const & path ); } // namespace doxybook #endif Updated on 2022-11-15 at 04:08:09 +0000","title":"Source code"},{"location":"reference/files/default__templates_8hpp/","text":"doxybook/default_templates.hpp Namespaces Name doxybook Classes Name struct doxybook::default_template Describe the default template for a page. Source code // // Copyright (c) 2021 Matus Novak (@matusnovak) // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #ifndef DOXYBOOK_DEFAULT_TEMPLATES_HPP #define DOXYBOOK_DEFAULT_TEMPLATES_HPP #include <string> #include <vector> #include <unordered_map> namespace doxybook { struct default_template { std :: string src ; std :: vector < std :: string > dependencies ; }; extern std :: unordered_map < std :: string , default_template > default_templates ; void save_default_templates ( std :: string const & path ); } // namespace doxybook #endif Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook/default_templates.hpp"},{"location":"reference/files/default__templates_8hpp/#doxybookdefault_templateshpp","text":"","title":"doxybook/default_templates.hpp"},{"location":"reference/files/default__templates_8hpp/#namespaces","text":"Name doxybook","title":"Namespaces"},{"location":"reference/files/default__templates_8hpp/#classes","text":"Name struct doxybook::default_template Describe the default template for a page.","title":"Classes"},{"location":"reference/files/default__templates_8hpp/#source-code","text":"// // Copyright (c) 2021 Matus Novak (@matusnovak) // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #ifndef DOXYBOOK_DEFAULT_TEMPLATES_HPP #define DOXYBOOK_DEFAULT_TEMPLATES_HPP #include <string> #include <vector> #include <unordered_map> namespace doxybook { struct default_template { std :: string src ; std :: vector < std :: string > dependencies ; }; extern std :: unordered_map < std :: string , default_template > default_templates ; void save_default_templates ( std :: string const & path ); } // namespace doxybook #endif Updated on 2022-11-15 at 04:08:09 +0000","title":"Source code"},{"location":"reference/files/dir_be054a2fbefc2d6b92396c28cd6dc939/","text":"doxybook Files Name doxybook/config.hpp doxybook/default_templates.hpp doxybook/doxygen.hpp doxybook/enums.hpp doxybook/exception.hpp doxybook/exception_utils.hpp doxybook/generator.hpp doxybook/json_converter.hpp doxybook/node.hpp doxybook/path.hpp doxybook/renderer.hpp doxybook/text_markdown_printer.hpp doxybook/text_plain_printer.hpp doxybook/text_printer.hpp doxybook/utils.hpp doxybook/xml.hpp doxybook/xml_text_parser.hpp Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook"},{"location":"reference/files/dir_be054a2fbefc2d6b92396c28cd6dc939/#doxybook","text":"","title":"doxybook"},{"location":"reference/files/dir_be054a2fbefc2d6b92396c28cd6dc939/#files","text":"Name doxybook/config.hpp doxybook/default_templates.hpp doxybook/doxygen.hpp doxybook/enums.hpp doxybook/exception.hpp doxybook/exception_utils.hpp doxybook/generator.hpp doxybook/json_converter.hpp doxybook/node.hpp doxybook/path.hpp doxybook/renderer.hpp doxybook/text_markdown_printer.hpp doxybook/text_plain_printer.hpp doxybook/text_printer.hpp doxybook/utils.hpp doxybook/xml.hpp doxybook/xml_text_parser.hpp Updated on 2022-11-15 at 04:08:09 +0000","title":"Files"},{"location":"reference/files/doxygen_8hpp/","text":"doxybook/doxygen.hpp Namespaces Name doxybook Classes Name class doxybook::doxygen All the nodes representing the content of doxygen xml files. Source code // // Copyright (c) 2021 Matus Novak (@matusnovak) // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #ifndef DOXYBOOK_DOXYGEN_HPP #define DOXYBOOK_DOXYGEN_HPP #include <doxybook/node.hpp> #include <string> #include <unordered_map> namespace doxybook { class text_printer ; class doxygen { public : explicit doxygen ( config const & c ); virtual ~ doxygen () = default ; void load ( std :: string const & input_dir ); void finalize ( text_printer const & plain_printer , text_printer const & markdown_printer ); node const & get_index () const { return * index_ ; } std :: shared_ptr < node > find ( std :: string const & refid ) const ; node_cache_map const & get_cache () const { return cache_ ; } private : // A map with the refids of each kind using kind_refid_map = std :: unordered_multimap < std :: string , std :: string > ; kind_refid_map get_index_kinds ( std :: string const & input_dir ) const ; void get_index_cache ( node_cache_map & cache , std :: shared_ptr < node > const & node ) const ; // Finalize given a certain node, which might have child nodes void finalize_recursively ( text_printer const & plain_printer , text_printer const & markdown_printer , std :: shared_ptr < node > const & node ); void update_group_pointers ( std :: shared_ptr < node > const & node ); config const & config_ ; // The root object that holds everything (index.xml) std :: shared_ptr < node > index_ ; node_cache_map cache_ ; }; } // namespace doxybook #endif Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook/doxygen.hpp"},{"location":"reference/files/doxygen_8hpp/#doxybookdoxygenhpp","text":"","title":"doxybook/doxygen.hpp"},{"location":"reference/files/doxygen_8hpp/#namespaces","text":"Name doxybook","title":"Namespaces"},{"location":"reference/files/doxygen_8hpp/#classes","text":"Name class doxybook::doxygen All the nodes representing the content of doxygen xml files.","title":"Classes"},{"location":"reference/files/doxygen_8hpp/#source-code","text":"// // Copyright (c) 2021 Matus Novak (@matusnovak) // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #ifndef DOXYBOOK_DOXYGEN_HPP #define DOXYBOOK_DOXYGEN_HPP #include <doxybook/node.hpp> #include <string> #include <unordered_map> namespace doxybook { class text_printer ; class doxygen { public : explicit doxygen ( config const & c ); virtual ~ doxygen () = default ; void load ( std :: string const & input_dir ); void finalize ( text_printer const & plain_printer , text_printer const & markdown_printer ); node const & get_index () const { return * index_ ; } std :: shared_ptr < node > find ( std :: string const & refid ) const ; node_cache_map const & get_cache () const { return cache_ ; } private : // A map with the refids of each kind using kind_refid_map = std :: unordered_multimap < std :: string , std :: string > ; kind_refid_map get_index_kinds ( std :: string const & input_dir ) const ; void get_index_cache ( node_cache_map & cache , std :: shared_ptr < node > const & node ) const ; // Finalize given a certain node, which might have child nodes void finalize_recursively ( text_printer const & plain_printer , text_printer const & markdown_printer , std :: shared_ptr < node > const & node ); void update_group_pointers ( std :: shared_ptr < node > const & node ); config const & config_ ; // The root object that holds everything (index.xml) std :: shared_ptr < node > index_ ; node_cache_map cache_ ; }; } // namespace doxybook #endif Updated on 2022-11-15 at 04:08:09 +0000","title":"Source code"},{"location":"reference/files/enums_8hpp/","text":"doxybook/enums.hpp Namespaces Name doxybook Source code // // Copyright (c) 2021 Matus Novak (@matusnovak) // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #ifndef DOXYBOOK_ENUMS_HPP #define DOXYBOOK_ENUMS_HPP #include <nlohmann/json.hpp> #include <string> namespace doxybook { struct config ; enum class kind { INDEX , DEFINE , CLASS , NAMESPACE , STRUCT , INTERFACE , FUNCTION , VARIABLE , TYPEDEF , USING , FRIEND , ENUM , ENUMVALUE , UNION , DIR , FILE , MODULE , PAGE , EXAMPLE , SIGNAL , SLOT , PROPERTY , EVENT , JAVAENUM , JAVAENUMCONSTANT }; enum class visibility { PUBLIC , PROTECTED , PRIVATE , PACKAGE }; enum class virtual_category { NON_VIRTUAL , VIRTUAL , PURE_VIRTUAL }; enum class type { NONE , DEFINES , FUNCTIONS , NAMESPACES , CLASSES , ATTRIBUTES , TYPES , DIRS , FILES , MODULES , FRIENDS , PAGES , EXAMPLES , SIGNALS , SLOTS , EVENTS , PROPERTIES , JAVAENUMCONSTANTS }; enum class folder_category { CLASSES , NAMESPACES , MODULES , PAGES , FILES , EXAMPLES }; extern kind to_enum_kind ( std :: string const & str ); extern type to_enum_type ( std :: string const & str ); extern visibility to_enum_visibility ( std :: string const & str ); extern virtual_category to_enum_virtual ( std :: string const & str ); extern folder_category to_enum_folder_category ( std :: string const & str ); extern std :: string to_str ( kind value ); extern std :: string to_str ( type value ); extern std :: string to_str ( visibility value ); extern std :: string to_str ( virtual_category value ); extern std :: string to_str ( folder_category value ); extern type kind_to_type ( kind kind ); extern bool is_kind_language ( kind kind ); extern bool is_kind_structured ( kind kind ); extern bool is_kind_file ( kind kind ); extern std :: string type_folder_category_to_folder_name ( config const & config , folder_category type ); extern std :: string type_to_folder_name ( config const & config , type type ); extern std :: string type_to_index_name ( config const & config , folder_category type ); extern std :: string type_to_index_template ( config const & config , folder_category type ); extern std :: string type_to_index_title ( config const & config , folder_category type ); inline void to_json ( nlohmann :: json & j , visibility const & p ) { j = to_str ( p ); } inline void from_json ( nlohmann :: json const & j , visibility & p ) { p = to_enum_visibility ( j . get < std :: string > ()); } inline void to_json ( nlohmann :: json & j , folder_category const & p ) { j = to_str ( p ); } inline void from_json ( nlohmann :: json const & j , folder_category & p ) { p = to_enum_folder_category ( j . get < std :: string > ()); } } // namespace doxybook #endif Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook/enums.hpp"},{"location":"reference/files/enums_8hpp/#doxybookenumshpp","text":"","title":"doxybook/enums.hpp"},{"location":"reference/files/enums_8hpp/#namespaces","text":"Name doxybook","title":"Namespaces"},{"location":"reference/files/enums_8hpp/#source-code","text":"// // Copyright (c) 2021 Matus Novak (@matusnovak) // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #ifndef DOXYBOOK_ENUMS_HPP #define DOXYBOOK_ENUMS_HPP #include <nlohmann/json.hpp> #include <string> namespace doxybook { struct config ; enum class kind { INDEX , DEFINE , CLASS , NAMESPACE , STRUCT , INTERFACE , FUNCTION , VARIABLE , TYPEDEF , USING , FRIEND , ENUM , ENUMVALUE , UNION , DIR , FILE , MODULE , PAGE , EXAMPLE , SIGNAL , SLOT , PROPERTY , EVENT , JAVAENUM , JAVAENUMCONSTANT }; enum class visibility { PUBLIC , PROTECTED , PRIVATE , PACKAGE }; enum class virtual_category { NON_VIRTUAL , VIRTUAL , PURE_VIRTUAL }; enum class type { NONE , DEFINES , FUNCTIONS , NAMESPACES , CLASSES , ATTRIBUTES , TYPES , DIRS , FILES , MODULES , FRIENDS , PAGES , EXAMPLES , SIGNALS , SLOTS , EVENTS , PROPERTIES , JAVAENUMCONSTANTS }; enum class folder_category { CLASSES , NAMESPACES , MODULES , PAGES , FILES , EXAMPLES }; extern kind to_enum_kind ( std :: string const & str ); extern type to_enum_type ( std :: string const & str ); extern visibility to_enum_visibility ( std :: string const & str ); extern virtual_category to_enum_virtual ( std :: string const & str ); extern folder_category to_enum_folder_category ( std :: string const & str ); extern std :: string to_str ( kind value ); extern std :: string to_str ( type value ); extern std :: string to_str ( visibility value ); extern std :: string to_str ( virtual_category value ); extern std :: string to_str ( folder_category value ); extern type kind_to_type ( kind kind ); extern bool is_kind_language ( kind kind ); extern bool is_kind_structured ( kind kind ); extern bool is_kind_file ( kind kind ); extern std :: string type_folder_category_to_folder_name ( config const & config , folder_category type ); extern std :: string type_to_folder_name ( config const & config , type type ); extern std :: string type_to_index_name ( config const & config , folder_category type ); extern std :: string type_to_index_template ( config const & config , folder_category type ); extern std :: string type_to_index_title ( config const & config , folder_category type ); inline void to_json ( nlohmann :: json & j , visibility const & p ) { j = to_str ( p ); } inline void from_json ( nlohmann :: json const & j , visibility & p ) { p = to_enum_visibility ( j . get < std :: string > ()); } inline void to_json ( nlohmann :: json & j , folder_category const & p ) { j = to_str ( p ); } inline void from_json ( nlohmann :: json const & j , folder_category & p ) { p = to_enum_folder_category ( j . get < std :: string > ()); } } // namespace doxybook #endif Updated on 2022-11-15 at 04:08:09 +0000","title":"Source code"},{"location":"reference/files/exception_8hpp/","text":"doxybook/exception.hpp Namespaces Name doxybook Classes Name class doxybook::exception Doxybook exceptions. Source code // // Copyright (c) 2021 Matus Novak (@matusnovak) // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #ifndef DOXYBOOK_EXCEPTION_HPP #define DOXYBOOK_EXCEPTION_HPP #include <string> namespace doxybook { class exception : public std :: exception { public : exception () = default ; explicit exception ( std :: string msg ) : msg_ ( std :: move ( msg )) {} char const * what () const throw () override { return msg_ . c_str (); } private : std :: string msg_ ; }; } // namespace doxybook #endif Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook/exception.hpp"},{"location":"reference/files/exception_8hpp/#doxybookexceptionhpp","text":"","title":"doxybook/exception.hpp"},{"location":"reference/files/exception_8hpp/#namespaces","text":"Name doxybook","title":"Namespaces"},{"location":"reference/files/exception_8hpp/#classes","text":"Name class doxybook::exception Doxybook exceptions.","title":"Classes"},{"location":"reference/files/exception_8hpp/#source-code","text":"// // Copyright (c) 2021 Matus Novak (@matusnovak) // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #ifndef DOXYBOOK_EXCEPTION_HPP #define DOXYBOOK_EXCEPTION_HPP #include <string> namespace doxybook { class exception : public std :: exception { public : exception () = default ; explicit exception ( std :: string msg ) : msg_ ( std :: move ( msg )) {} char const * what () const throw () override { return msg_ . c_str (); } private : std :: string msg_ ; }; } // namespace doxybook #endif Updated on 2022-11-15 at 04:08:09 +0000","title":"Source code"},{"location":"reference/files/exception__utils_8hpp/","text":"doxybook/exception_utils.hpp Defines Name FILENAME EXCEPTION (MSG, ...) WARNING (MSG, ...) Macros Documentation define FILENAME #define __FILENAME__ doxybook::path::filename(__FILE__) define EXCEPTION #define EXCEPTION( MSG , ... ) doxybook :: exception ( \\ fmt :: format ( \"Exception at {}:{} \" , __FILENAME__ , __LINE__ ) \\ + fmt :: format ( MSG , ## __VA_ARGS__ )) define WARNING #define WARNING( MSG , ... ) doxybook :: spdlog :: warn ( \\ fmt :: format ( \"Warning at {}:{} \" , __FILENAME__ , __LINE__ ) \\ + fmt :: format ( MSG , ## __VA_ARGS__ )) Source code // // Copyright (c) 2021 Matus Novak (@matusnovak) // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #ifndef DOXYBOOK_EXCEPTION_UTILS_HPP #define DOXYBOOK_EXCEPTION_UTILS_HPP #include <doxybook/exception.hpp> #include <doxybook/path.hpp> #include <fmt/format.h> #define __FILENAME__ doxybook::path::filename(__FILE__) #define EXCEPTION(MSG, ...) \\ doxybook::exception( \\ fmt::format(\"Exception at {}:{} \", __FILENAME__, __LINE__) \\ + fmt::format(MSG, ##__VA_ARGS__)) #define WARNING(MSG, ...) \\ doxybook::spdlog::warn( \\ fmt::format(\"Warning at {}:{} \", __FILENAME__, __LINE__) \\ + fmt::format(MSG, ##__VA_ARGS__)) #endif Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook/exception_utils.hpp"},{"location":"reference/files/exception__utils_8hpp/#doxybookexception_utilshpp","text":"","title":"doxybook/exception_utils.hpp"},{"location":"reference/files/exception__utils_8hpp/#defines","text":"Name FILENAME EXCEPTION (MSG, ...) WARNING (MSG, ...)","title":"Defines"},{"location":"reference/files/exception__utils_8hpp/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"reference/files/exception__utils_8hpp/#define-filename","text":"#define __FILENAME__ doxybook::path::filename(__FILE__)","title":"define FILENAME"},{"location":"reference/files/exception__utils_8hpp/#define-exception","text":"#define EXCEPTION( MSG , ... ) doxybook :: exception ( \\ fmt :: format ( \"Exception at {}:{} \" , __FILENAME__ , __LINE__ ) \\ + fmt :: format ( MSG , ## __VA_ARGS__ ))","title":"define EXCEPTION"},{"location":"reference/files/exception__utils_8hpp/#define-warning","text":"#define WARNING( MSG , ... ) doxybook :: spdlog :: warn ( \\ fmt :: format ( \"Warning at {}:{} \" , __FILENAME__ , __LINE__ ) \\ + fmt :: format ( MSG , ## __VA_ARGS__ ))","title":"define WARNING"},{"location":"reference/files/exception__utils_8hpp/#source-code","text":"// // Copyright (c) 2021 Matus Novak (@matusnovak) // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #ifndef DOXYBOOK_EXCEPTION_UTILS_HPP #define DOXYBOOK_EXCEPTION_UTILS_HPP #include <doxybook/exception.hpp> #include <doxybook/path.hpp> #include <fmt/format.h> #define __FILENAME__ doxybook::path::filename(__FILE__) #define EXCEPTION(MSG, ...) \\ doxybook::exception( \\ fmt::format(\"Exception at {}:{} \", __FILENAME__, __LINE__) \\ + fmt::format(MSG, ##__VA_ARGS__)) #define WARNING(MSG, ...) \\ doxybook::spdlog::warn( \\ fmt::format(\"Warning at {}:{} \", __FILENAME__, __LINE__) \\ + fmt::format(MSG, ##__VA_ARGS__)) #endif Updated on 2022-11-15 at 04:08:09 +0000","title":"Source code"},{"location":"reference/files/generator_8hpp/","text":"doxybook/generator.hpp Namespaces Name doxybook Classes Name class doxybook::generator A class that stores a doxygen object and generates the markdown documentation. struct doxybook::generator::summary_section A section we should generate. Source code // // Copyright (c) 2021 Matus Novak (@matusnovak) // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #ifndef DOXYBOOK_GENERATOR_HPP #define DOXYBOOK_GENERATOR_HPP #include <doxybook/doxygen.hpp> #include <doxybook/json_converter.hpp> #include <doxybook/renderer.hpp> #include <string> #include <unordered_set> namespace doxybook { class generator { public : using filter_set = std :: unordered_set < kind > ; struct summary_section { folder_category type ; filter_set filter ; filter_set skip ; }; explicit generator ( config const & config , doxygen const & doxygen , json_converter const & json_converter , std :: optional < std :: string > const & templates_path ); void print ( filter_set const & filter , filter_set const & skip ); void json ( filter_set const & filter , filter_set const & skip ); void manifest (); void print_index ( folder_category type , filter_set const & filter , filter_set const & skip ); void summary ( std :: string const & input_file , std :: string const & output_file , std :: vector < summary_section > const & sections ); private : void print_recursively ( node const & parent , filter_set const & filter , filter_set const & skip ); nlohmann :: json manifest_recursively ( node const & node ); void json_recursively ( node const & parent , filter_set const & filter , filter_set const & skip ); std :: string kind_to_template_name ( kind kind ); nlohmann :: json build_index_recursively ( node const & node , filter_set const & filter , filter_set const & skip ); void summary_recursive ( std :: stringstream & ss , int indent , std :: string const & folderName , node const & node , filter_set const & filter , filter_set const & skip ); bool should_include ( node const & node ); config const & config_ ; doxygen const & doxygen_ ; json_converter const & json_converter_ ; renderer renderer_ ; }; } // namespace doxybook #endif Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook/generator.hpp"},{"location":"reference/files/generator_8hpp/#doxybookgeneratorhpp","text":"","title":"doxybook/generator.hpp"},{"location":"reference/files/generator_8hpp/#namespaces","text":"Name doxybook","title":"Namespaces"},{"location":"reference/files/generator_8hpp/#classes","text":"Name class doxybook::generator A class that stores a doxygen object and generates the markdown documentation. struct doxybook::generator::summary_section A section we should generate.","title":"Classes"},{"location":"reference/files/generator_8hpp/#source-code","text":"// // Copyright (c) 2021 Matus Novak (@matusnovak) // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #ifndef DOXYBOOK_GENERATOR_HPP #define DOXYBOOK_GENERATOR_HPP #include <doxybook/doxygen.hpp> #include <doxybook/json_converter.hpp> #include <doxybook/renderer.hpp> #include <string> #include <unordered_set> namespace doxybook { class generator { public : using filter_set = std :: unordered_set < kind > ; struct summary_section { folder_category type ; filter_set filter ; filter_set skip ; }; explicit generator ( config const & config , doxygen const & doxygen , json_converter const & json_converter , std :: optional < std :: string > const & templates_path ); void print ( filter_set const & filter , filter_set const & skip ); void json ( filter_set const & filter , filter_set const & skip ); void manifest (); void print_index ( folder_category type , filter_set const & filter , filter_set const & skip ); void summary ( std :: string const & input_file , std :: string const & output_file , std :: vector < summary_section > const & sections ); private : void print_recursively ( node const & parent , filter_set const & filter , filter_set const & skip ); nlohmann :: json manifest_recursively ( node const & node ); void json_recursively ( node const & parent , filter_set const & filter , filter_set const & skip ); std :: string kind_to_template_name ( kind kind ); nlohmann :: json build_index_recursively ( node const & node , filter_set const & filter , filter_set const & skip ); void summary_recursive ( std :: stringstream & ss , int indent , std :: string const & folderName , node const & node , filter_set const & filter , filter_set const & skip ); bool should_include ( node const & node ); config const & config_ ; doxygen const & doxygen_ ; json_converter const & json_converter_ ; renderer renderer_ ; }; } // namespace doxybook #endif Updated on 2022-11-15 at 04:08:09 +0000","title":"Source code"},{"location":"reference/files/json__converter_8hpp/","text":"doxybook/json_converter.hpp Namespaces Name doxybook Classes Name class doxybook::json_converter Convert elements to json so they can be rendered with inja. Source code // // Copyright (c) 2021 Matus Novak (@matusnovak) // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #ifndef DOXYBOOK_JSON_CONVERTER_HPP #define DOXYBOOK_JSON_CONVERTER_HPP #include <doxybook/config.hpp> #include <doxybook/node.hpp> #include <doxybook/text_printer.hpp> #include <nlohmann/json.hpp> namespace doxybook { class json_converter { public : explicit json_converter ( config const & config , doxygen const & doxygen , text_printer const & plainPrinter , text_printer const & markdownPrinter ); nlohmann :: json convert ( std :: vector < std :: string > const & vec ) const ; nlohmann :: json convert ( node :: class_reference const & class_ ) const ; nlohmann :: json convert ( std :: vector < node :: class_reference > const & classes ) const ; nlohmann :: json convert ( node :: source_location const & location ) const ; nlohmann :: json convert ( node :: param const & param ) const ; nlohmann :: json convert ( node :: parameter_list_item const & item ) const ; nlohmann :: json convert ( std :: vector < node :: parameter_list_item > const & item ) const ; nlohmann :: json convert ( node const & node ) const ; nlohmann :: json convert ( node const & node , node :: data const & data ) const ; nlohmann :: json get_as_json ( node const & node ) const ; private : config const & config_ ; doxygen const & doxygen_ ; text_printer const & plain_printer_ ; text_printer const & markdown_printer_ ; }; } // namespace doxybook #endif Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook/json_converter.hpp"},{"location":"reference/files/json__converter_8hpp/#doxybookjson_converterhpp","text":"","title":"doxybook/json_converter.hpp"},{"location":"reference/files/json__converter_8hpp/#namespaces","text":"Name doxybook","title":"Namespaces"},{"location":"reference/files/json__converter_8hpp/#classes","text":"Name class doxybook::json_converter Convert elements to json so they can be rendered with inja.","title":"Classes"},{"location":"reference/files/json__converter_8hpp/#source-code","text":"// // Copyright (c) 2021 Matus Novak (@matusnovak) // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #ifndef DOXYBOOK_JSON_CONVERTER_HPP #define DOXYBOOK_JSON_CONVERTER_HPP #include <doxybook/config.hpp> #include <doxybook/node.hpp> #include <doxybook/text_printer.hpp> #include <nlohmann/json.hpp> namespace doxybook { class json_converter { public : explicit json_converter ( config const & config , doxygen const & doxygen , text_printer const & plainPrinter , text_printer const & markdownPrinter ); nlohmann :: json convert ( std :: vector < std :: string > const & vec ) const ; nlohmann :: json convert ( node :: class_reference const & class_ ) const ; nlohmann :: json convert ( std :: vector < node :: class_reference > const & classes ) const ; nlohmann :: json convert ( node :: source_location const & location ) const ; nlohmann :: json convert ( node :: param const & param ) const ; nlohmann :: json convert ( node :: parameter_list_item const & item ) const ; nlohmann :: json convert ( std :: vector < node :: parameter_list_item > const & item ) const ; nlohmann :: json convert ( node const & node ) const ; nlohmann :: json convert ( node const & node , node :: data const & data ) const ; nlohmann :: json get_as_json ( node const & node ) const ; private : config const & config_ ; doxygen const & doxygen_ ; text_printer const & plain_printer_ ; text_printer const & markdown_printer_ ; }; } // namespace doxybook #endif Updated on 2022-11-15 at 04:08:09 +0000","title":"Source code"},{"location":"reference/files/node_8hpp/","text":"doxybook/node.hpp Namespaces Name doxybook Classes Name class doxybook::node A doxygen node. struct doxybook::node::class_reference A reference to a class. struct doxybook::node::source_location Source code location. struct doxybook::node::param A parameter. struct doxybook::node::parameter_list_item An item in a list of parameters. struct doxybook::node::data The data in a doxygen node. Source code // // Copyright (c) 2021 Matus Novak (@matusnovak) // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #ifndef DOXYBOOK_NODE_HPP #define DOXYBOOK_NODE_HPP #include <doxybook/enums.hpp> #include <doxybook/xml.hpp> #include <list> #include <memory> #include <string> #include <vector> #include <unordered_map> namespace doxybook { class text_printer ; class node ; struct config ; using node_cache_map = std :: unordered_map < std :: string , std :: shared_ptr < node >> ; class node { public : struct class_reference { std :: string name ; std :: string refid ; visibility prot ; virtual_category virt ; node const * ptr { nullptr }; }; struct source_location { std :: string file ; int line { 0 }; int column { 0 }; std :: string body_file ; int body_start { 0 }; int body_end { 0 }; }; struct param { std :: string type ; std :: string type_plain ; std :: string name ; std :: string def_val ; std :: string def_val_plain ; }; struct parameter_list_item { std :: string name ; std :: string text ; }; struct data { std :: vector < class_reference > base_classes ; std :: string definition ; std :: string args_string ; std :: string initializer ; std :: vector < class_reference > derived_classes ; bool is_abstract { false }; bool is_static { false }; bool is_const { false }; bool is_explicit { false }; bool is_strong { false }; bool is_inline { false }; bool is_default { false }; bool is_deleted { false }; bool is_override { false }; source_location location ; std :: string details ; std :: string in_body ; std :: string includes ; std :: string type ; std :: string type_plain ; std :: string deprecated ; std :: vector < param > params ; std :: vector < param > template_params ; std :: vector < std :: string > see ; std :: vector < std :: string > returns ; std :: vector < std :: string > authors ; std :: vector < std :: string > version ; std :: vector < std :: string > since ; std :: vector < std :: string > date ; std :: vector < std :: string > note ; std :: vector < std :: string > warning ; std :: vector < std :: string > pre ; std :: vector < std :: string > post ; std :: vector < std :: string > copyright ; std :: vector < std :: string > invariant ; std :: vector < std :: string > remark ; std :: vector < std :: string > attention ; std :: vector < std :: string > par ; std :: vector < std :: string > rcs ; std :: vector < std :: string > bugs ; std :: vector < std :: string > tests ; std :: vector < std :: string > todos ; std :: vector < node :: parameter_list_item > param_list ; std :: vector < node :: parameter_list_item > returns_list ; std :: vector < node :: parameter_list_item > template_params_list ; std :: vector < node :: parameter_list_item > exceptions_list ; node const * reimplements { nullptr }; std :: vector < node const *> reimplemented_by ; std :: string program_listing ; }; static std :: shared_ptr < node > parse ( node_cache_map & cache , std :: string const & input_dir , std :: string const & refid , bool is_group_or_file ); static std :: shared_ptr < node > parse ( node_cache_map & cache , std :: string const & input_dir , std :: shared_ptr < node > const & ptr , bool is_group_or_file ); static std :: shared_ptr < node > parse ( xml :: element & member_def , std :: string const & ref_id ); explicit node ( std :: string const & refid ); ~ node (); std :: shared_ptr < node > find ( std :: string const & refid ) const ; std :: shared_ptr < node > find_child ( std :: string const & refid ) const ; bool is_structured () const { return is_kind_structured ( kind_ ); } bool is_language () const { return is_kind_language ( kind_ ); } bool is_file_or_dir () const { return is_kind_file ( kind_ ); } kind get_kind () const { return kind_ ; } std :: string get_language () const { return language_ ; } type get_type () const { return type_ ; } std :: string const & get_refid () const { return refid_ ; } std :: string const & get_qualified_name () const { return qualified_name_ ; } std :: string const & get_name () const { return name_ ; } node const * get_parent () const { return parent_ ; } node const * get_group () const { return group_ ; } bool is_empty () const { return empty_ ; } std :: list < std :: shared_ptr < node >> const & get_children () const { return children_ ; } std :: string const & get_xml_path () const { return xml_path_ ; } std :: string const & get_brief () const { return brief_ ; } std :: string const & get_summary () const { return summary_ ; } std :: string const & get_title () const { return title_ ; } visibility get_visibility () const { return visibility_ ; } virtual_category get_virtual () const { return virt_ ; } std :: vector < class_reference > const & get_base_classes () const { return base_classes_ ; } std :: vector < class_reference > const & get_derived_classes () const { return derived_classes_ ; } std :: string const & get_url () const { return url_ ; } std :: string const & get_anchor () const { return anchor_ ; } void finalize ( config const & config , text_printer const & plain_printer , text_printer const & markdown_printer , node_cache_map const & cache ); using load_data_result = std :: tuple < data , std :: unordered_map < std :: string , data >> ; load_data_result load_data ( config const & config , text_printer const & plain_printer , text_printer const & markdown_printer , node_cache_map const & cache ) const ; friend class doxygen ; private : class Temp ; data load_data ( config const & config , text_printer const & plain_printer , text_printer const & markdown_printer , node_cache_map const & cache , xml :: element const & element ) const ; std :: vector < class_reference > get_all_base_classes ( node_cache_map const & cache ); std :: unique_ptr < Temp > temp_ ; kind kind_ { kind :: INDEX }; type type_ { type :: NONE }; std :: string language_ ; std :: string refid_ ; std :: string name_ ; std :: string qualified_name_ ; std :: string brief_ ; std :: string summary_ ; std :: string title_ ; node * parent_ { nullptr }; node * group_ { nullptr }; std :: list < std :: shared_ptr < node >> children_ ; bool empty_ { true }; std :: string xml_path_ ; std :: vector < class_reference > base_classes_ ; std :: vector < class_reference > derived_classes_ ; visibility visibility_ { visibility :: PUBLIC }; virtual_category virt_ { virtual_category :: NON_VIRTUAL }; std :: string url_ ; std :: string anchor_ ; void parse_base_info ( xml :: element const & element ); void parse_inheritance_info ( xml :: element const & element ); std :: shared_ptr < node > find_recursively ( std :: string const & refid ) const ; static xml :: element assert_child ( xml :: element const & xml , std :: string const & name ); static xml :: element assert_child ( xml const & xml , std :: string const & name ); }; } // namespace doxybook #endif Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook/node.hpp"},{"location":"reference/files/node_8hpp/#doxybooknodehpp","text":"","title":"doxybook/node.hpp"},{"location":"reference/files/node_8hpp/#namespaces","text":"Name doxybook","title":"Namespaces"},{"location":"reference/files/node_8hpp/#classes","text":"Name class doxybook::node A doxygen node. struct doxybook::node::class_reference A reference to a class. struct doxybook::node::source_location Source code location. struct doxybook::node::param A parameter. struct doxybook::node::parameter_list_item An item in a list of parameters. struct doxybook::node::data The data in a doxygen node.","title":"Classes"},{"location":"reference/files/node_8hpp/#source-code","text":"// // Copyright (c) 2021 Matus Novak (@matusnovak) // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #ifndef DOXYBOOK_NODE_HPP #define DOXYBOOK_NODE_HPP #include <doxybook/enums.hpp> #include <doxybook/xml.hpp> #include <list> #include <memory> #include <string> #include <vector> #include <unordered_map> namespace doxybook { class text_printer ; class node ; struct config ; using node_cache_map = std :: unordered_map < std :: string , std :: shared_ptr < node >> ; class node { public : struct class_reference { std :: string name ; std :: string refid ; visibility prot ; virtual_category virt ; node const * ptr { nullptr }; }; struct source_location { std :: string file ; int line { 0 }; int column { 0 }; std :: string body_file ; int body_start { 0 }; int body_end { 0 }; }; struct param { std :: string type ; std :: string type_plain ; std :: string name ; std :: string def_val ; std :: string def_val_plain ; }; struct parameter_list_item { std :: string name ; std :: string text ; }; struct data { std :: vector < class_reference > base_classes ; std :: string definition ; std :: string args_string ; std :: string initializer ; std :: vector < class_reference > derived_classes ; bool is_abstract { false }; bool is_static { false }; bool is_const { false }; bool is_explicit { false }; bool is_strong { false }; bool is_inline { false }; bool is_default { false }; bool is_deleted { false }; bool is_override { false }; source_location location ; std :: string details ; std :: string in_body ; std :: string includes ; std :: string type ; std :: string type_plain ; std :: string deprecated ; std :: vector < param > params ; std :: vector < param > template_params ; std :: vector < std :: string > see ; std :: vector < std :: string > returns ; std :: vector < std :: string > authors ; std :: vector < std :: string > version ; std :: vector < std :: string > since ; std :: vector < std :: string > date ; std :: vector < std :: string > note ; std :: vector < std :: string > warning ; std :: vector < std :: string > pre ; std :: vector < std :: string > post ; std :: vector < std :: string > copyright ; std :: vector < std :: string > invariant ; std :: vector < std :: string > remark ; std :: vector < std :: string > attention ; std :: vector < std :: string > par ; std :: vector < std :: string > rcs ; std :: vector < std :: string > bugs ; std :: vector < std :: string > tests ; std :: vector < std :: string > todos ; std :: vector < node :: parameter_list_item > param_list ; std :: vector < node :: parameter_list_item > returns_list ; std :: vector < node :: parameter_list_item > template_params_list ; std :: vector < node :: parameter_list_item > exceptions_list ; node const * reimplements { nullptr }; std :: vector < node const *> reimplemented_by ; std :: string program_listing ; }; static std :: shared_ptr < node > parse ( node_cache_map & cache , std :: string const & input_dir , std :: string const & refid , bool is_group_or_file ); static std :: shared_ptr < node > parse ( node_cache_map & cache , std :: string const & input_dir , std :: shared_ptr < node > const & ptr , bool is_group_or_file ); static std :: shared_ptr < node > parse ( xml :: element & member_def , std :: string const & ref_id ); explicit node ( std :: string const & refid ); ~ node (); std :: shared_ptr < node > find ( std :: string const & refid ) const ; std :: shared_ptr < node > find_child ( std :: string const & refid ) const ; bool is_structured () const { return is_kind_structured ( kind_ ); } bool is_language () const { return is_kind_language ( kind_ ); } bool is_file_or_dir () const { return is_kind_file ( kind_ ); } kind get_kind () const { return kind_ ; } std :: string get_language () const { return language_ ; } type get_type () const { return type_ ; } std :: string const & get_refid () const { return refid_ ; } std :: string const & get_qualified_name () const { return qualified_name_ ; } std :: string const & get_name () const { return name_ ; } node const * get_parent () const { return parent_ ; } node const * get_group () const { return group_ ; } bool is_empty () const { return empty_ ; } std :: list < std :: shared_ptr < node >> const & get_children () const { return children_ ; } std :: string const & get_xml_path () const { return xml_path_ ; } std :: string const & get_brief () const { return brief_ ; } std :: string const & get_summary () const { return summary_ ; } std :: string const & get_title () const { return title_ ; } visibility get_visibility () const { return visibility_ ; } virtual_category get_virtual () const { return virt_ ; } std :: vector < class_reference > const & get_base_classes () const { return base_classes_ ; } std :: vector < class_reference > const & get_derived_classes () const { return derived_classes_ ; } std :: string const & get_url () const { return url_ ; } std :: string const & get_anchor () const { return anchor_ ; } void finalize ( config const & config , text_printer const & plain_printer , text_printer const & markdown_printer , node_cache_map const & cache ); using load_data_result = std :: tuple < data , std :: unordered_map < std :: string , data >> ; load_data_result load_data ( config const & config , text_printer const & plain_printer , text_printer const & markdown_printer , node_cache_map const & cache ) const ; friend class doxygen ; private : class Temp ; data load_data ( config const & config , text_printer const & plain_printer , text_printer const & markdown_printer , node_cache_map const & cache , xml :: element const & element ) const ; std :: vector < class_reference > get_all_base_classes ( node_cache_map const & cache ); std :: unique_ptr < Temp > temp_ ; kind kind_ { kind :: INDEX }; type type_ { type :: NONE }; std :: string language_ ; std :: string refid_ ; std :: string name_ ; std :: string qualified_name_ ; std :: string brief_ ; std :: string summary_ ; std :: string title_ ; node * parent_ { nullptr }; node * group_ { nullptr }; std :: list < std :: shared_ptr < node >> children_ ; bool empty_ { true }; std :: string xml_path_ ; std :: vector < class_reference > base_classes_ ; std :: vector < class_reference > derived_classes_ ; visibility visibility_ { visibility :: PUBLIC }; virtual_category virt_ { virtual_category :: NON_VIRTUAL }; std :: string url_ ; std :: string anchor_ ; void parse_base_info ( xml :: element const & element ); void parse_inheritance_info ( xml :: element const & element ); std :: shared_ptr < node > find_recursively ( std :: string const & refid ) const ; static xml :: element assert_child ( xml :: element const & xml , std :: string const & name ); static xml :: element assert_child ( xml const & xml , std :: string const & name ); }; } // namespace doxybook #endif Updated on 2022-11-15 at 04:08:09 +0000","title":"Source code"},{"location":"reference/files/path_8hpp/","text":"doxybook/path.hpp Namespaces Name doxybook doxybook::path Source code // // Copyright (c) 2021 Matus Novak (@matusnovak) // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #ifndef DOXYBOOK_PATH_HPP #define DOXYBOOK_PATH_HPP #include <algorithm> #include <sstream> #include <string> namespace doxybook { namespace path { namespace detail { // Stream first to output inline void join ( std :: stringstream & ss , std :: string const & first ) { ss << first ; } // Stream args to output as directory template < typename ... Args > inline void join ( std :: stringstream & ss , std :: string const & first , Args const & ... args ) { #ifdef _WIN32 ss << first << \" \\\\ \" ; #else ss << first << \"/\" ; #endif detail :: join ( ss , args ...); } } // namespace detail template < typename ... Args > inline std :: string join ( Args const & ... args ) { std :: stringstream ss ; detail :: join ( ss , args ...); return ss . str (); } inline std :: string filename ( std :: string const & path ) { auto const a = path . find_last_of ( '/' ); auto const b = path . find_last_of ( '\\\\' ); if ( a != std :: string :: npos && b != std :: string :: npos ) { return path . substr ( std :: max < size_t > ( a , b ) + 1 ); } else if ( a != std :: string :: npos ) { return path . substr ( a + 1 ); } else if ( b != std :: string :: npos ) { return path . substr ( b + 1 ); } else { return path ; } } }; // namespace path } // namespace doxybook #endif Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook/path.hpp"},{"location":"reference/files/path_8hpp/#doxybookpathhpp","text":"","title":"doxybook/path.hpp"},{"location":"reference/files/path_8hpp/#namespaces","text":"Name doxybook doxybook::path","title":"Namespaces"},{"location":"reference/files/path_8hpp/#source-code","text":"// // Copyright (c) 2021 Matus Novak (@matusnovak) // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #ifndef DOXYBOOK_PATH_HPP #define DOXYBOOK_PATH_HPP #include <algorithm> #include <sstream> #include <string> namespace doxybook { namespace path { namespace detail { // Stream first to output inline void join ( std :: stringstream & ss , std :: string const & first ) { ss << first ; } // Stream args to output as directory template < typename ... Args > inline void join ( std :: stringstream & ss , std :: string const & first , Args const & ... args ) { #ifdef _WIN32 ss << first << \" \\\\ \" ; #else ss << first << \"/\" ; #endif detail :: join ( ss , args ...); } } // namespace detail template < typename ... Args > inline std :: string join ( Args const & ... args ) { std :: stringstream ss ; detail :: join ( ss , args ...); return ss . str (); } inline std :: string filename ( std :: string const & path ) { auto const a = path . find_last_of ( '/' ); auto const b = path . find_last_of ( '\\\\' ); if ( a != std :: string :: npos && b != std :: string :: npos ) { return path . substr ( std :: max < size_t > ( a , b ) + 1 ); } else if ( a != std :: string :: npos ) { return path . substr ( a + 1 ); } else if ( b != std :: string :: npos ) { return path . substr ( b + 1 ); } else { return path ; } } }; // namespace path } // namespace doxybook #endif Updated on 2022-11-15 at 04:08:09 +0000","title":"Source code"},{"location":"reference/files/renderer_8hpp/","text":"doxybook/renderer.hpp Namespaces Name doxybook Classes Name class doxybook::renderer Render inja templates with the specified configuration. Source code // // Copyright (c) 2021 Matus Novak (@matusnovak) // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #ifndef DOXYBOOK_RENDERER_HPP #define DOXYBOOK_RENDERER_HPP #include <doxybook/config.hpp> #include <doxybook/doxygen.hpp> #include <doxybook/json_converter.hpp> #include <nlohmann/json.hpp> #include <memory> #include <optional> #include <string> #include <unordered_map> namespace inja { struct Template ; class Environment ; } // namespace inja namespace doxybook { class renderer { public : explicit renderer ( config const & config , doxygen const & doxygen , json_converter const & json_converter , std :: optional < std :: string > const & templates_path = std :: nullopt ); ~ renderer (); void render ( std :: string const & name , std :: string const & path , nlohmann :: json const & data ) const ; std :: string render ( std :: string const & name , nlohmann :: json const & data ) const ; private : config const & config_ ; doxygen const & doxygen_ ; json_converter const & json_converter_ ; std :: unique_ptr < inja :: Environment > env_ ; std :: unordered_map < std :: string , std :: unique_ptr < inja :: Template >> templates_ ; }; } // namespace doxybook #endif Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook/renderer.hpp"},{"location":"reference/files/renderer_8hpp/#doxybookrendererhpp","text":"","title":"doxybook/renderer.hpp"},{"location":"reference/files/renderer_8hpp/#namespaces","text":"Name doxybook","title":"Namespaces"},{"location":"reference/files/renderer_8hpp/#classes","text":"Name class doxybook::renderer Render inja templates with the specified configuration.","title":"Classes"},{"location":"reference/files/renderer_8hpp/#source-code","text":"// // Copyright (c) 2021 Matus Novak (@matusnovak) // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #ifndef DOXYBOOK_RENDERER_HPP #define DOXYBOOK_RENDERER_HPP #include <doxybook/config.hpp> #include <doxybook/doxygen.hpp> #include <doxybook/json_converter.hpp> #include <nlohmann/json.hpp> #include <memory> #include <optional> #include <string> #include <unordered_map> namespace inja { struct Template ; class Environment ; } // namespace inja namespace doxybook { class renderer { public : explicit renderer ( config const & config , doxygen const & doxygen , json_converter const & json_converter , std :: optional < std :: string > const & templates_path = std :: nullopt ); ~ renderer (); void render ( std :: string const & name , std :: string const & path , nlohmann :: json const & data ) const ; std :: string render ( std :: string const & name , nlohmann :: json const & data ) const ; private : config const & config_ ; doxygen const & doxygen_ ; json_converter const & json_converter_ ; std :: unique_ptr < inja :: Environment > env_ ; std :: unordered_map < std :: string , std :: unique_ptr < inja :: Template >> templates_ ; }; } // namespace doxybook #endif Updated on 2022-11-15 at 04:08:09 +0000","title":"Source code"},{"location":"reference/files/text__markdown__printer_8hpp/","text":"doxybook/text_markdown_printer.hpp Namespaces Name doxybook Classes Name class doxybook::text_markdown_printer Print xml nodes as markdown. Source code // // Copyright (c) 2021 Matus Novak (@matusnovak) // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #ifndef DOXYBOOK_TEXT_MARKDOWN_PRINTER_HPP #define DOXYBOOK_TEXT_MARKDOWN_PRINTER_HPP #include <doxybook/text_printer.hpp> #include <sstream> namespace doxybook { class text_markdown_printer : public text_printer { public : explicit text_markdown_printer ( config const & config , std :: string input_dir , doxygen const & doxygen ) : text_printer ( config , doxygen ) , input_dir_ ( std :: move ( input_dir )) {} std :: string print ( xml_text_parser :: node const & node , std :: string const & language ) const override ; private : struct list_data { int counter { 0 }; bool ordered { false }; }; struct print_data { std :: stringstream ss ; int indent { 0 }; std :: list < list_data > lists ; bool quote { false }; bool eol { false }; bool table_header { false }; bool in_computer_output { false }; bool valid_link { false }; }; void print ( print_data & data , xml_text_parser :: node const * parent , xml_text_parser :: node const * node , xml_text_parser :: node const * previous , xml_text_parser :: node const * next , std :: string const & language ) const ; void program_listing ( print_data & data , xml_text_parser :: node const & node ) const ; std :: string input_dir_ ; }; } // namespace doxybook #endif Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook/text_markdown_printer.hpp"},{"location":"reference/files/text__markdown__printer_8hpp/#doxybooktext_markdown_printerhpp","text":"","title":"doxybook/text_markdown_printer.hpp"},{"location":"reference/files/text__markdown__printer_8hpp/#namespaces","text":"Name doxybook","title":"Namespaces"},{"location":"reference/files/text__markdown__printer_8hpp/#classes","text":"Name class doxybook::text_markdown_printer Print xml nodes as markdown.","title":"Classes"},{"location":"reference/files/text__markdown__printer_8hpp/#source-code","text":"// // Copyright (c) 2021 Matus Novak (@matusnovak) // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #ifndef DOXYBOOK_TEXT_MARKDOWN_PRINTER_HPP #define DOXYBOOK_TEXT_MARKDOWN_PRINTER_HPP #include <doxybook/text_printer.hpp> #include <sstream> namespace doxybook { class text_markdown_printer : public text_printer { public : explicit text_markdown_printer ( config const & config , std :: string input_dir , doxygen const & doxygen ) : text_printer ( config , doxygen ) , input_dir_ ( std :: move ( input_dir )) {} std :: string print ( xml_text_parser :: node const & node , std :: string const & language ) const override ; private : struct list_data { int counter { 0 }; bool ordered { false }; }; struct print_data { std :: stringstream ss ; int indent { 0 }; std :: list < list_data > lists ; bool quote { false }; bool eol { false }; bool table_header { false }; bool in_computer_output { false }; bool valid_link { false }; }; void print ( print_data & data , xml_text_parser :: node const * parent , xml_text_parser :: node const * node , xml_text_parser :: node const * previous , xml_text_parser :: node const * next , std :: string const & language ) const ; void program_listing ( print_data & data , xml_text_parser :: node const & node ) const ; std :: string input_dir_ ; }; } // namespace doxybook #endif Updated on 2022-11-15 at 04:08:09 +0000","title":"Source code"},{"location":"reference/files/text__plain__printer_8hpp/","text":"doxybook/text_plain_printer.hpp Namespaces Name doxybook Classes Name class doxybook::text_plain_printer Print elements as plain text. Source code // // Copyright (c) 2021 Matus Novak (@matusnovak) // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #ifndef DOXYBOOK_TEXT_PLAIN_PRINTER_HPP #define DOXYBOOK_TEXT_PLAIN_PRINTER_HPP #include <doxybook/text_printer.hpp> namespace doxybook { class text_plain_printer : public text_printer { public : explicit text_plain_printer ( config const & config , doxygen const & doxygen ) : text_printer ( config , doxygen ) {} std :: string print ( xml_text_parser :: node const & node , std :: string const & language ) const override ; private : void print ( std :: stringstream & ss , xml_text_parser :: node const & node ) const ; }; } // namespace doxybook #endif Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook/text_plain_printer.hpp"},{"location":"reference/files/text__plain__printer_8hpp/#doxybooktext_plain_printerhpp","text":"","title":"doxybook/text_plain_printer.hpp"},{"location":"reference/files/text__plain__printer_8hpp/#namespaces","text":"Name doxybook","title":"Namespaces"},{"location":"reference/files/text__plain__printer_8hpp/#classes","text":"Name class doxybook::text_plain_printer Print elements as plain text.","title":"Classes"},{"location":"reference/files/text__plain__printer_8hpp/#source-code","text":"// // Copyright (c) 2021 Matus Novak (@matusnovak) // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #ifndef DOXYBOOK_TEXT_PLAIN_PRINTER_HPP #define DOXYBOOK_TEXT_PLAIN_PRINTER_HPP #include <doxybook/text_printer.hpp> namespace doxybook { class text_plain_printer : public text_printer { public : explicit text_plain_printer ( config const & config , doxygen const & doxygen ) : text_printer ( config , doxygen ) {} std :: string print ( xml_text_parser :: node const & node , std :: string const & language ) const override ; private : void print ( std :: stringstream & ss , xml_text_parser :: node const & node ) const ; }; } // namespace doxybook #endif Updated on 2022-11-15 at 04:08:09 +0000","title":"Source code"},{"location":"reference/files/text__printer_8hpp/","text":"doxybook/text_printer.hpp Namespaces Name doxybook Classes Name class doxybook::text_printer An abstract text printer. Source code // // Copyright (c) 2021 Matus Novak (@matusnovak) // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #ifndef DOXYBOOK_TEXT_PRINTER_HPP #define DOXYBOOK_TEXT_PRINTER_HPP #include <doxybook/config.hpp> #include <doxybook/node.hpp> #include <doxybook/xml_text_parser.hpp> #include <string> namespace doxybook { class doxygen ; class text_printer { public : explicit text_printer ( config const & config , doxygen const & doxygen ) : config_ ( config ) , doxygen_ ( doxygen ) {} virtual ~ text_printer () = default ; virtual std :: string print ( xml_text_parser :: node const & node , std :: string const & language = \"cpp\" ) const = 0 ; protected : config const & config_ ; doxygen const & doxygen_ ; }; } // namespace doxybook #endif Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook/text_printer.hpp"},{"location":"reference/files/text__printer_8hpp/#doxybooktext_printerhpp","text":"","title":"doxybook/text_printer.hpp"},{"location":"reference/files/text__printer_8hpp/#namespaces","text":"Name doxybook","title":"Namespaces"},{"location":"reference/files/text__printer_8hpp/#classes","text":"Name class doxybook::text_printer An abstract text printer.","title":"Classes"},{"location":"reference/files/text__printer_8hpp/#source-code","text":"// // Copyright (c) 2021 Matus Novak (@matusnovak) // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #ifndef DOXYBOOK_TEXT_PRINTER_HPP #define DOXYBOOK_TEXT_PRINTER_HPP #include <doxybook/config.hpp> #include <doxybook/node.hpp> #include <doxybook/xml_text_parser.hpp> #include <string> namespace doxybook { class doxygen ; class text_printer { public : explicit text_printer ( config const & config , doxygen const & doxygen ) : config_ ( config ) , doxygen_ ( doxygen ) {} virtual ~ text_printer () = default ; virtual std :: string print ( xml_text_parser :: node const & node , std :: string const & language = \"cpp\" ) const = 0 ; protected : config const & config_ ; doxygen const & doxygen_ ; }; } // namespace doxybook #endif Updated on 2022-11-15 at 04:08:09 +0000","title":"Source code"},{"location":"reference/files/utils_8hpp/","text":"doxybook/utils.hpp Namespaces Name doxybook doxybook::utils Source code // // Copyright (c) 2021 Matus Novak (@matusnovak) // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #ifndef DOXYBOOK_UTILS_HPP #define DOXYBOOK_UTILS_HPP #include <algorithm> #include <sstream> #include <string> #include <vector> namespace doxybook { namespace utils { namespace detail { inline void join ( std :: stringstream & ss , std :: string const & first ) { ss << first ; } template < typename ... Args > inline void join ( std :: stringstream & ss , std :: string const & first , Args const & ... args ) { #ifdef _WIN32 ss << first << \" \\\\ \" ; #else ss << first << \"/\" ; #endif detail :: join ( ss , args ...); } } // namespace detail template < typename ... Args > inline std :: string join ( Args const & ... args ) { std :: stringstream ss ; detail :: join ( ss , args ...); return ss . str (); } inline std :: string filename ( std :: string const & path ) { auto const a = path . find_last_of ( '/' ); auto const b = path . find_last_of ( '\\\\' ); if ( a != std :: string :: npos && b != std :: string :: npos ) { return path . substr ( std :: max < size_t > ( a , b ) + 1 ); } else if ( a != std :: string :: npos ) { return path . substr ( a + 1 ); } else if ( b != std :: string :: npos ) { return path . substr ( b + 1 ); } else { return path ; } } extern std :: string escape ( std :: string str ); extern std :: string title ( std :: string str ); extern std :: string to_lower ( std :: string str ); extern std :: string safe_anchor_id ( std :: string str , bool replace_underscores ); extern std :: string namespace_to_package ( std :: string str ); extern std :: string date ( std :: string const & format ); extern std :: string strip_namespace ( std :: string const & format ); extern std :: string strip_anchor ( std :: string const & str ); extern std :: vector < std :: string > split ( std :: string const & str , std :: string const & delim ); extern void create_directory ( std :: string const & path ); extern std :: string normalize_language ( std :: string const & language ); extern std :: string replace_newline ( std :: string str ); } // namespace utils } // namespace doxybook #endif Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook/utils.hpp"},{"location":"reference/files/utils_8hpp/#doxybookutilshpp","text":"","title":"doxybook/utils.hpp"},{"location":"reference/files/utils_8hpp/#namespaces","text":"Name doxybook doxybook::utils","title":"Namespaces"},{"location":"reference/files/utils_8hpp/#source-code","text":"// // Copyright (c) 2021 Matus Novak (@matusnovak) // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #ifndef DOXYBOOK_UTILS_HPP #define DOXYBOOK_UTILS_HPP #include <algorithm> #include <sstream> #include <string> #include <vector> namespace doxybook { namespace utils { namespace detail { inline void join ( std :: stringstream & ss , std :: string const & first ) { ss << first ; } template < typename ... Args > inline void join ( std :: stringstream & ss , std :: string const & first , Args const & ... args ) { #ifdef _WIN32 ss << first << \" \\\\ \" ; #else ss << first << \"/\" ; #endif detail :: join ( ss , args ...); } } // namespace detail template < typename ... Args > inline std :: string join ( Args const & ... args ) { std :: stringstream ss ; detail :: join ( ss , args ...); return ss . str (); } inline std :: string filename ( std :: string const & path ) { auto const a = path . find_last_of ( '/' ); auto const b = path . find_last_of ( '\\\\' ); if ( a != std :: string :: npos && b != std :: string :: npos ) { return path . substr ( std :: max < size_t > ( a , b ) + 1 ); } else if ( a != std :: string :: npos ) { return path . substr ( a + 1 ); } else if ( b != std :: string :: npos ) { return path . substr ( b + 1 ); } else { return path ; } } extern std :: string escape ( std :: string str ); extern std :: string title ( std :: string str ); extern std :: string to_lower ( std :: string str ); extern std :: string safe_anchor_id ( std :: string str , bool replace_underscores ); extern std :: string namespace_to_package ( std :: string str ); extern std :: string date ( std :: string const & format ); extern std :: string strip_namespace ( std :: string const & format ); extern std :: string strip_anchor ( std :: string const & str ); extern std :: vector < std :: string > split ( std :: string const & str , std :: string const & delim ); extern void create_directory ( std :: string const & path ); extern std :: string normalize_language ( std :: string const & language ); extern std :: string replace_newline ( std :: string str ); } // namespace utils } // namespace doxybook #endif Updated on 2022-11-15 at 04:08:09 +0000","title":"Source code"},{"location":"reference/files/xml_8hpp/","text":"doxybook/xml.hpp Namespaces Name doxybook Classes Name class doxybook::xml Represents and wraps an xml node. class doxybook::xml::node An xml node. class doxybook::xml::element The data of an element nodes. Source code // // Copyright (c) 2021 Matus Novak (@matusnovak) // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #ifndef DOXYBOOK_XML_HPP #define DOXYBOOK_XML_HPP #include <functional> #include <memory> #include <string> namespace tinyxml2 { class XMLNode ; class XMLElement ; class XMLDocument ; } // namespace tinyxml2 namespace doxybook { class xml { public : class element ; using element_callback = std :: function < void ( element & ) > ; class node { public : node () = default ; explicit node ( tinyxml2 :: XMLNode * ptr ); ~ node () = default ; node next_sibling () const ; node first_child () const ; bool has_text () const ; std :: string get_text () const ; bool is_element () const ; element as_element () const ; operator bool () const { return ptr != nullptr ; } private : tinyxml2 :: XMLNode * ptr { nullptr }; }; class element { public : element () = default ; explicit element ( tinyxml2 :: XMLElement * ptr ); ~ element () = default ; void all_child_elements ( std :: string const & name , element_callback const & callback ) const ; node as_node () const ; element next_sibling_element () const ; node next_sibling () const ; element next_sibling_element ( std :: string const & name ) const ; node first_child () const ; element first_child_element () const ; element first_child_element ( std :: string const & name ) const ; int get_line () const ; xml const & get_document () const ; std :: string get_attr ( std :: string const & name ) const ; std :: string get_attr ( std :: string const & name , std :: string const & default_value ) const ; std :: string get_name () const ; bool has_text () const ; std :: string get_text () const ; operator bool () const { return ptr != nullptr ; } private : tinyxml2 :: XMLElement * ptr { nullptr }; }; explicit xml ( std :: string const & path ); ~ xml (); element first_child_element ( std :: string const & name ) const ; std :: string const & get_path () const { return path_ ; } private : std :: unique_ptr < tinyxml2 :: XMLDocument > doc_ ; std :: string path_ ; }; } // namespace doxybook #endif Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook/xml.hpp"},{"location":"reference/files/xml_8hpp/#doxybookxmlhpp","text":"","title":"doxybook/xml.hpp"},{"location":"reference/files/xml_8hpp/#namespaces","text":"Name doxybook","title":"Namespaces"},{"location":"reference/files/xml_8hpp/#classes","text":"Name class doxybook::xml Represents and wraps an xml node. class doxybook::xml::node An xml node. class doxybook::xml::element The data of an element nodes.","title":"Classes"},{"location":"reference/files/xml_8hpp/#source-code","text":"// // Copyright (c) 2021 Matus Novak (@matusnovak) // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #ifndef DOXYBOOK_XML_HPP #define DOXYBOOK_XML_HPP #include <functional> #include <memory> #include <string> namespace tinyxml2 { class XMLNode ; class XMLElement ; class XMLDocument ; } // namespace tinyxml2 namespace doxybook { class xml { public : class element ; using element_callback = std :: function < void ( element & ) > ; class node { public : node () = default ; explicit node ( tinyxml2 :: XMLNode * ptr ); ~ node () = default ; node next_sibling () const ; node first_child () const ; bool has_text () const ; std :: string get_text () const ; bool is_element () const ; element as_element () const ; operator bool () const { return ptr != nullptr ; } private : tinyxml2 :: XMLNode * ptr { nullptr }; }; class element { public : element () = default ; explicit element ( tinyxml2 :: XMLElement * ptr ); ~ element () = default ; void all_child_elements ( std :: string const & name , element_callback const & callback ) const ; node as_node () const ; element next_sibling_element () const ; node next_sibling () const ; element next_sibling_element ( std :: string const & name ) const ; node first_child () const ; element first_child_element () const ; element first_child_element ( std :: string const & name ) const ; int get_line () const ; xml const & get_document () const ; std :: string get_attr ( std :: string const & name ) const ; std :: string get_attr ( std :: string const & name , std :: string const & default_value ) const ; std :: string get_name () const ; bool has_text () const ; std :: string get_text () const ; operator bool () const { return ptr != nullptr ; } private : tinyxml2 :: XMLElement * ptr { nullptr }; }; explicit xml ( std :: string const & path ); ~ xml (); element first_child_element ( std :: string const & name ) const ; std :: string const & get_path () const { return path_ ; } private : std :: unique_ptr < tinyxml2 :: XMLDocument > doc_ ; std :: string path_ ; }; } // namespace doxybook #endif Updated on 2022-11-15 at 04:08:09 +0000","title":"Source code"},{"location":"reference/files/xml__text__parser_8hpp/","text":"doxybook/xml_text_parser.hpp Namespaces Name doxybook Classes Name class doxybook::xml_text_parser Parser for a doxygen xml file as an xml document. struct doxybook::xml_text_parser::node A parsed xml node. Source code // // Copyright (c) 2021 Matus Novak (@matusnovak) // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #ifndef DOXYBOOK_XML_TEXT_PARSER_HPP #define DOXYBOOK_XML_TEXT_PARSER_HPP #include <doxybook/xml.hpp> #include <string> #include <vector> namespace doxybook { class xml_text_parser { public : class tag ; using children_type = std :: vector < std :: unique_ptr < tag >> ; struct node { enum class type { UNKNOWN = -1 , TEXT = 0 , PARA , PARAS , BOLD , EMPHASIS , STRIKE , HRULER , IMAGE , ULINK , REF , COMPUTEROUTPUT , LISTITEM , SIMPLESEC , ITEMIZEDLIST , VARIABLELIST , ORDEREDLIST , PARAMETERLIST , PARAMETERNAME , PARAMETERITEM , PARAMETERDESCRIPTION , PARAMETERNAMELIST , XREFSECT , XREFTITLE , XREFDESCRIPTION , PROGRAMLISTING , CODELINE , TERM , VARLISTENTRY , ANCHOR , SP , HIGHTLIGHT , SECT1 , SECT2 , SECT3 , SECT4 , SECT5 , SECT6 , TITLE , SUPERSCRIPT , NONBREAKSPACE , TABLE , TABLE_ROW , TABLE_CELL , VERBATIM , SQUO , NDASH , MDASH , LINEBREAK , ONLYFOR , FORMULA , BLOCKQUOTE , }; type type { type :: UNKNOWN }; std :: vector < node > children ; std :: string data ; std :: string extra ; }; static node parse_paras ( xml :: element const & element ); static node parse_para ( xml :: element const & element ); static enum node :: type str_to_type ( std :: string const & str ); private : static void traverse ( std :: vector < node *> tree , xml :: node const & element ); }; } // namespace doxybook #endif Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook/xml_text_parser.hpp"},{"location":"reference/files/xml__text__parser_8hpp/#doxybookxml_text_parserhpp","text":"","title":"doxybook/xml_text_parser.hpp"},{"location":"reference/files/xml__text__parser_8hpp/#namespaces","text":"Name doxybook","title":"Namespaces"},{"location":"reference/files/xml__text__parser_8hpp/#classes","text":"Name class doxybook::xml_text_parser Parser for a doxygen xml file as an xml document. struct doxybook::xml_text_parser::node A parsed xml node.","title":"Classes"},{"location":"reference/files/xml__text__parser_8hpp/#source-code","text":"// // Copyright (c) 2021 Matus Novak (@matusnovak) // Copyright (c) 2022 alandefreitas (alandefreitas@gmail.com) // // Distributed under the Boost Software License, Version 1.0. // https://www.boost.org/LICENSE_1_0.txt // #ifndef DOXYBOOK_XML_TEXT_PARSER_HPP #define DOXYBOOK_XML_TEXT_PARSER_HPP #include <doxybook/xml.hpp> #include <string> #include <vector> namespace doxybook { class xml_text_parser { public : class tag ; using children_type = std :: vector < std :: unique_ptr < tag >> ; struct node { enum class type { UNKNOWN = -1 , TEXT = 0 , PARA , PARAS , BOLD , EMPHASIS , STRIKE , HRULER , IMAGE , ULINK , REF , COMPUTEROUTPUT , LISTITEM , SIMPLESEC , ITEMIZEDLIST , VARIABLELIST , ORDEREDLIST , PARAMETERLIST , PARAMETERNAME , PARAMETERITEM , PARAMETERDESCRIPTION , PARAMETERNAMELIST , XREFSECT , XREFTITLE , XREFDESCRIPTION , PROGRAMLISTING , CODELINE , TERM , VARLISTENTRY , ANCHOR , SP , HIGHTLIGHT , SECT1 , SECT2 , SECT3 , SECT4 , SECT5 , SECT6 , TITLE , SUPERSCRIPT , NONBREAKSPACE , TABLE , TABLE_ROW , TABLE_CELL , VERBATIM , SQUO , NDASH , MDASH , LINEBREAK , ONLYFOR , FORMULA , BLOCKQUOTE , }; type type { type :: UNKNOWN }; std :: vector < node > children ; std :: string data ; std :: string extra ; }; static node parse_paras ( xml :: element const & element ); static node parse_para ( xml :: element const & element ); static enum node :: type str_to_type ( std :: string const & str ); private : static void traverse ( std :: vector < node *> tree , xml :: node const & element ); }; } // namespace doxybook #endif Updated on 2022-11-15 at 04:08:09 +0000","title":"Source code"},{"location":"reference/modules/","text":"Modules Updated on 2022-11-15 at 04:08:09 +0000","title":"Modules"},{"location":"reference/modules/#modules","text":"Updated on 2022-11-15 at 04:08:09 +0000","title":"Modules"},{"location":"reference/namespaces/","text":"Namespaces namespace doxybook namespace path namespace utils Updated on 2022-11-15 at 04:08:09 +0000","title":"Namespaces"},{"location":"reference/namespaces/#namespaces","text":"namespace doxybook namespace path namespace utils Updated on 2022-11-15 at 04:08:09 +0000","title":"Namespaces"},{"location":"reference/namespaces/namespacedoxybook/","text":"doxybook Namespaces Name doxybook::path doxybook::utils Classes Name struct doxybook::config Configuration for the doxygen and generator classes. struct doxybook::default_template Describe the default template for a page. class doxybook::doxygen All the nodes representing the content of doxygen xml files. class doxybook::exception Doxybook exceptions. class doxybook::generator A class that stores a doxygen object and generates the markdown documentation. class doxybook::json_converter Convert elements to json so they can be rendered with inja. class doxybook::node A doxygen node. class doxybook::renderer Render inja templates with the specified configuration. class doxybook::text_markdown_printer Print xml nodes as markdown. class doxybook::text_plain_printer Print elements as plain text. class doxybook::text_printer An abstract text printer. class doxybook::xml Represents and wraps an xml node. class doxybook::xml_text_parser Parser for a doxygen xml file as an xml document. Types Name enum class kind { INDEX, DEFINE, CLASS, NAMESPACE, STRUCT, INTERFACE, FUNCTION, VARIABLE, TYPEDEF, USING, FRIEND, ENUM, ENUMVALUE, UNION, DIR, FILE, MODULE, PAGE, EXAMPLE, SIGNAL, SLOT, PROPERTY, EVENT, JAVAENUM, JAVAENUMCONSTANT} The kind of a symbol in a doxygen xml file. enum class visibility { PUBLIC, PROTECTED, PRIVATE, PACKAGE} Types of symbol visibility. enum class virtual_category { NON_VIRTUAL, VIRTUAL, PURE_VIRTUAL} Types of virtual functions. enum class type { NONE, DEFINES, FUNCTIONS, NAMESPACES, CLASSES, ATTRIBUTES, TYPES, DIRS, FILES, MODULES, FRIENDS, PAGES, EXAMPLES, SIGNALS, SLOTS, EVENTS, PROPERTIES, JAVAENUMCONSTANTS} Doxygen types. enum class folder_category { CLASSES, NAMESPACES, MODULES, PAGES, FILES, EXAMPLES} Types of folder category. using std::unordered_map< std::string, std::shared_ptr< node > > node_cache_map A map of nodes associated to a string. Functions Name void load_config ( config & config, std::string const & path) Load configuration from a path. void load_config_data ( config & config, std::string_view src) Load configuration from a json string. void save_config ( config & config, std::string const & path) Save configuration to a path. void save_default_templates (std::string const & path) Save default templates. kind to_enum_kind (std::string const & str) Convert a string to a doxygen kind. type to_enum_type (std::string const & str) Convert a string to a doxygen type. visibility to_enum_visibility (std::string const & str) Convert a string to a doxygen visibility type. virtual_category to_enum_virtual (std::string const & str) Convert a string to a doxygen virtual category. folder_category to_enum_folder_category (std::string const & str) Convert a string to a doxygen folder category. std::string to_str ( kind value) Convert a kind to a string. std::string to_str ( type value) Convert a type to a string. std::string to_str ( visibility value) Convert a visibility to a string. std::string to_str ( virtual_category value) Convert a virtual_category to a string. std::string to_str ( folder_category value) Convert a folder_category to a string. type kind_to_type ( kind kind) Convert a kind to a type. bool is_kind_language ( kind kind) Determine if kind is a language feature. bool is_kind_structured ( kind kind) Determine if kind is a structured type. bool is_kind_file ( kind kind) Determine if kind is a file or directory. std::string type_folder_category_to_folder_name ( config const & config, folder_category type) Determine the appropriate folder name for a folder category. std::string type_to_folder_name ( config const & config, type type) Determine the appropriate folder name for a type. std::string type_to_index_name ( config const & config, folder_category type) Determine the appropriate index file name for a folder category. std::string type_to_index_template ( config const & config, folder_category type) Determine the appropriate index template file name for a folder category. std::string type_to_index_title ( config const & config, folder_category type) Determine the appropriate index title name for a folder category. void to_json (nlohmann::json & j, visibility const & p) Convert a visibility type to a json string. void from_json (nlohmann::json const & j, visibility & p) Convert a json string to a visibility type. void to_json (nlohmann::json & j, folder_category const & p) Convert a folder category to a json string. void from_json (nlohmann::json const & j, folder_category & p) Convert a json string to a folder category. Attributes Name std::unordered_map< std::string, default_template > default_templates A map with all the default templates. Types Documentation enum kind Enumerator Value Description INDEX DEFINE CLASS NAMESPACE STRUCT INTERFACE FUNCTION VARIABLE TYPEDEF USING FRIEND ENUM ENUMVALUE UNION DIR FILE MODULE PAGE EXAMPLE SIGNAL SLOT PROPERTY EVENT JAVAENUM JAVAENUMCONSTANT The kind of a symbol in a doxygen xml file. enum visibility Enumerator Value Description PUBLIC PROTECTED PRIVATE PACKAGE Types of symbol visibility. enum virtual_category Enumerator Value Description NON_VIRTUAL VIRTUAL PURE_VIRTUAL Types of virtual functions. enum type Enumerator Value Description NONE DEFINES FUNCTIONS NAMESPACES CLASSES ATTRIBUTES TYPES DIRS FILES MODULES FRIENDS PAGES EXAMPLES SIGNALS SLOTS EVENTS PROPERTIES JAVAENUMCONSTANTS Doxygen types. enum folder_category Enumerator Value Description CLASSES NAMESPACES MODULES PAGES FILES EXAMPLES Types of folder category. using node_cache_map using doxybook :: node_cache_map = typedef std :: unordered_map < std :: string , std :: shared_ptr < node > > ; A map of nodes associated to a string. Functions Documentation function load_config void load_config ( config & config , std :: string const & path ) Load configuration from a path. function load_config_data void load_config_data ( config & config , std :: string_view src ) Load configuration from a json string. function save_config void save_config ( config & config , std :: string const & path ) Save configuration to a path. function save_default_templates void save_default_templates ( std :: string const & path ) Save default templates. This function stores all the default templates to files. The user can edit these templates to come up with new templates. function to_enum_kind kind to_enum_kind ( std :: string const & str ) Convert a string to a doxygen kind. function to_enum_type type to_enum_type ( std :: string const & str ) Convert a string to a doxygen type. function to_enum_visibility visibility to_enum_visibility ( std :: string const & str ) Convert a string to a doxygen visibility type. function to_enum_virtual virtual_category to_enum_virtual ( std :: string const & str ) Convert a string to a doxygen virtual category. function to_enum_folder_category folder_category to_enum_folder_category ( std :: string const & str ) Convert a string to a doxygen folder category. function to_str std :: string to_str ( kind value ) Convert a kind to a string. function to_str std :: string to_str ( type value ) Convert a type to a string. function to_str std :: string to_str ( visibility value ) Convert a visibility to a string. function to_str std :: string to_str ( virtual_category value ) Convert a virtual_category to a string. function to_str std :: string to_str ( folder_category value ) Convert a folder_category to a string. function kind_to_type type kind_to_type ( kind kind ) Convert a kind to a type. function is_kind_language bool is_kind_language ( kind kind ) Determine if kind is a language feature. function is_kind_structured bool is_kind_structured ( kind kind ) Determine if kind is a structured type. function is_kind_file bool is_kind_file ( kind kind ) Determine if kind is a file or directory. function type_folder_category_to_folder_name std :: string type_folder_category_to_folder_name ( config const & config , folder_category type ) Determine the appropriate folder name for a folder category. Return : The folder name Get the appropriate folder name in the configuration file for the specified folder category. Not all types have corresponding folder categories. function type_to_folder_name std :: string type_to_folder_name ( config const & config , type type ) Determine the appropriate folder name for a type. Return : The folder name Get the appropriate folder name in the configuration file for the specified type. Not all types have corresponding folder categories. function type_to_index_name std :: string type_to_index_name ( config const & config , folder_category type ) Determine the appropriate index file name for a folder category. Return : The folder name Get the appropriate index file name in the configuration file for the specified folder category. Not all types have corresponding folder categories. function type_to_index_template std :: string type_to_index_template ( config const & config , folder_category type ) Determine the appropriate index template file name for a folder category. Return : The folder name Get the appropriate template file name in the configuration file for the specified folder category. Not all types have corresponding folder categories. function type_to_index_title std :: string type_to_index_title ( config const & config , folder_category type ) Determine the appropriate index title name for a folder category. Return : The folder name Get the appropriate index title name in the configuration file for the specified folder category. Not all types have corresponding folder categories. function to_json inline void to_json ( nlohmann :: json & j , visibility const & p ) Convert a visibility type to a json string. function from_json inline void from_json ( nlohmann :: json const & j , visibility & p ) Convert a json string to a visibility type. function to_json inline void to_json ( nlohmann :: json & j , folder_category const & p ) Convert a folder category to a json string. function from_json inline void from_json ( nlohmann :: json const & j , folder_category & p ) Convert a json string to a folder category. Attributes Documentation variable default_templates std :: unordered_map < std :: string , default_template > default_templates ; A map with all the default templates. Unless template files are provided, these templates are used. Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook"},{"location":"reference/namespaces/namespacedoxybook/#doxybook","text":"","title":"doxybook"},{"location":"reference/namespaces/namespacedoxybook/#namespaces","text":"Name doxybook::path doxybook::utils","title":"Namespaces"},{"location":"reference/namespaces/namespacedoxybook/#classes","text":"Name struct doxybook::config Configuration for the doxygen and generator classes. struct doxybook::default_template Describe the default template for a page. class doxybook::doxygen All the nodes representing the content of doxygen xml files. class doxybook::exception Doxybook exceptions. class doxybook::generator A class that stores a doxygen object and generates the markdown documentation. class doxybook::json_converter Convert elements to json so they can be rendered with inja. class doxybook::node A doxygen node. class doxybook::renderer Render inja templates with the specified configuration. class doxybook::text_markdown_printer Print xml nodes as markdown. class doxybook::text_plain_printer Print elements as plain text. class doxybook::text_printer An abstract text printer. class doxybook::xml Represents and wraps an xml node. class doxybook::xml_text_parser Parser for a doxygen xml file as an xml document.","title":"Classes"},{"location":"reference/namespaces/namespacedoxybook/#types","text":"Name enum class kind { INDEX, DEFINE, CLASS, NAMESPACE, STRUCT, INTERFACE, FUNCTION, VARIABLE, TYPEDEF, USING, FRIEND, ENUM, ENUMVALUE, UNION, DIR, FILE, MODULE, PAGE, EXAMPLE, SIGNAL, SLOT, PROPERTY, EVENT, JAVAENUM, JAVAENUMCONSTANT} The kind of a symbol in a doxygen xml file. enum class visibility { PUBLIC, PROTECTED, PRIVATE, PACKAGE} Types of symbol visibility. enum class virtual_category { NON_VIRTUAL, VIRTUAL, PURE_VIRTUAL} Types of virtual functions. enum class type { NONE, DEFINES, FUNCTIONS, NAMESPACES, CLASSES, ATTRIBUTES, TYPES, DIRS, FILES, MODULES, FRIENDS, PAGES, EXAMPLES, SIGNALS, SLOTS, EVENTS, PROPERTIES, JAVAENUMCONSTANTS} Doxygen types. enum class folder_category { CLASSES, NAMESPACES, MODULES, PAGES, FILES, EXAMPLES} Types of folder category. using std::unordered_map< std::string, std::shared_ptr< node > > node_cache_map A map of nodes associated to a string.","title":"Types"},{"location":"reference/namespaces/namespacedoxybook/#functions","text":"Name void load_config ( config & config, std::string const & path) Load configuration from a path. void load_config_data ( config & config, std::string_view src) Load configuration from a json string. void save_config ( config & config, std::string const & path) Save configuration to a path. void save_default_templates (std::string const & path) Save default templates. kind to_enum_kind (std::string const & str) Convert a string to a doxygen kind. type to_enum_type (std::string const & str) Convert a string to a doxygen type. visibility to_enum_visibility (std::string const & str) Convert a string to a doxygen visibility type. virtual_category to_enum_virtual (std::string const & str) Convert a string to a doxygen virtual category. folder_category to_enum_folder_category (std::string const & str) Convert a string to a doxygen folder category. std::string to_str ( kind value) Convert a kind to a string. std::string to_str ( type value) Convert a type to a string. std::string to_str ( visibility value) Convert a visibility to a string. std::string to_str ( virtual_category value) Convert a virtual_category to a string. std::string to_str ( folder_category value) Convert a folder_category to a string. type kind_to_type ( kind kind) Convert a kind to a type. bool is_kind_language ( kind kind) Determine if kind is a language feature. bool is_kind_structured ( kind kind) Determine if kind is a structured type. bool is_kind_file ( kind kind) Determine if kind is a file or directory. std::string type_folder_category_to_folder_name ( config const & config, folder_category type) Determine the appropriate folder name for a folder category. std::string type_to_folder_name ( config const & config, type type) Determine the appropriate folder name for a type. std::string type_to_index_name ( config const & config, folder_category type) Determine the appropriate index file name for a folder category. std::string type_to_index_template ( config const & config, folder_category type) Determine the appropriate index template file name for a folder category. std::string type_to_index_title ( config const & config, folder_category type) Determine the appropriate index title name for a folder category. void to_json (nlohmann::json & j, visibility const & p) Convert a visibility type to a json string. void from_json (nlohmann::json const & j, visibility & p) Convert a json string to a visibility type. void to_json (nlohmann::json & j, folder_category const & p) Convert a folder category to a json string. void from_json (nlohmann::json const & j, folder_category & p) Convert a json string to a folder category.","title":"Functions"},{"location":"reference/namespaces/namespacedoxybook/#attributes","text":"Name std::unordered_map< std::string, default_template > default_templates A map with all the default templates.","title":"Attributes"},{"location":"reference/namespaces/namespacedoxybook/#types-documentation","text":"","title":"Types Documentation"},{"location":"reference/namespaces/namespacedoxybook/#enum-kind","text":"Enumerator Value Description INDEX DEFINE CLASS NAMESPACE STRUCT INTERFACE FUNCTION VARIABLE TYPEDEF USING FRIEND ENUM ENUMVALUE UNION DIR FILE MODULE PAGE EXAMPLE SIGNAL SLOT PROPERTY EVENT JAVAENUM JAVAENUMCONSTANT The kind of a symbol in a doxygen xml file.","title":"enum kind"},{"location":"reference/namespaces/namespacedoxybook/#enum-visibility","text":"Enumerator Value Description PUBLIC PROTECTED PRIVATE PACKAGE Types of symbol visibility.","title":"enum visibility"},{"location":"reference/namespaces/namespacedoxybook/#enum-virtual_category","text":"Enumerator Value Description NON_VIRTUAL VIRTUAL PURE_VIRTUAL Types of virtual functions.","title":"enum virtual_category"},{"location":"reference/namespaces/namespacedoxybook/#enum-type","text":"Enumerator Value Description NONE DEFINES FUNCTIONS NAMESPACES CLASSES ATTRIBUTES TYPES DIRS FILES MODULES FRIENDS PAGES EXAMPLES SIGNALS SLOTS EVENTS PROPERTIES JAVAENUMCONSTANTS Doxygen types.","title":"enum type"},{"location":"reference/namespaces/namespacedoxybook/#enum-folder_category","text":"Enumerator Value Description CLASSES NAMESPACES MODULES PAGES FILES EXAMPLES Types of folder category.","title":"enum folder_category"},{"location":"reference/namespaces/namespacedoxybook/#using-node_cache_map","text":"using doxybook :: node_cache_map = typedef std :: unordered_map < std :: string , std :: shared_ptr < node > > ; A map of nodes associated to a string.","title":"using node_cache_map"},{"location":"reference/namespaces/namespacedoxybook/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"reference/namespaces/namespacedoxybook/#function-load_config","text":"void load_config ( config & config , std :: string const & path ) Load configuration from a path.","title":"function load_config"},{"location":"reference/namespaces/namespacedoxybook/#function-load_config_data","text":"void load_config_data ( config & config , std :: string_view src ) Load configuration from a json string.","title":"function load_config_data"},{"location":"reference/namespaces/namespacedoxybook/#function-save_config","text":"void save_config ( config & config , std :: string const & path ) Save configuration to a path.","title":"function save_config"},{"location":"reference/namespaces/namespacedoxybook/#function-save_default_templates","text":"void save_default_templates ( std :: string const & path ) Save default templates. This function stores all the default templates to files. The user can edit these templates to come up with new templates.","title":"function save_default_templates"},{"location":"reference/namespaces/namespacedoxybook/#function-to_enum_kind","text":"kind to_enum_kind ( std :: string const & str ) Convert a string to a doxygen kind.","title":"function to_enum_kind"},{"location":"reference/namespaces/namespacedoxybook/#function-to_enum_type","text":"type to_enum_type ( std :: string const & str ) Convert a string to a doxygen type.","title":"function to_enum_type"},{"location":"reference/namespaces/namespacedoxybook/#function-to_enum_visibility","text":"visibility to_enum_visibility ( std :: string const & str ) Convert a string to a doxygen visibility type.","title":"function to_enum_visibility"},{"location":"reference/namespaces/namespacedoxybook/#function-to_enum_virtual","text":"virtual_category to_enum_virtual ( std :: string const & str ) Convert a string to a doxygen virtual category.","title":"function to_enum_virtual"},{"location":"reference/namespaces/namespacedoxybook/#function-to_enum_folder_category","text":"folder_category to_enum_folder_category ( std :: string const & str ) Convert a string to a doxygen folder category.","title":"function to_enum_folder_category"},{"location":"reference/namespaces/namespacedoxybook/#function-to_str","text":"std :: string to_str ( kind value ) Convert a kind to a string.","title":"function to_str"},{"location":"reference/namespaces/namespacedoxybook/#function-to_str_1","text":"std :: string to_str ( type value ) Convert a type to a string.","title":"function to_str"},{"location":"reference/namespaces/namespacedoxybook/#function-to_str_2","text":"std :: string to_str ( visibility value ) Convert a visibility to a string.","title":"function to_str"},{"location":"reference/namespaces/namespacedoxybook/#function-to_str_3","text":"std :: string to_str ( virtual_category value ) Convert a virtual_category to a string.","title":"function to_str"},{"location":"reference/namespaces/namespacedoxybook/#function-to_str_4","text":"std :: string to_str ( folder_category value ) Convert a folder_category to a string.","title":"function to_str"},{"location":"reference/namespaces/namespacedoxybook/#function-kind_to_type","text":"type kind_to_type ( kind kind ) Convert a kind to a type.","title":"function kind_to_type"},{"location":"reference/namespaces/namespacedoxybook/#function-is_kind_language","text":"bool is_kind_language ( kind kind ) Determine if kind is a language feature.","title":"function is_kind_language"},{"location":"reference/namespaces/namespacedoxybook/#function-is_kind_structured","text":"bool is_kind_structured ( kind kind ) Determine if kind is a structured type.","title":"function is_kind_structured"},{"location":"reference/namespaces/namespacedoxybook/#function-is_kind_file","text":"bool is_kind_file ( kind kind ) Determine if kind is a file or directory.","title":"function is_kind_file"},{"location":"reference/namespaces/namespacedoxybook/#function-type_folder_category_to_folder_name","text":"std :: string type_folder_category_to_folder_name ( config const & config , folder_category type ) Determine the appropriate folder name for a folder category. Return : The folder name Get the appropriate folder name in the configuration file for the specified folder category. Not all types have corresponding folder categories.","title":"function type_folder_category_to_folder_name"},{"location":"reference/namespaces/namespacedoxybook/#function-type_to_folder_name","text":"std :: string type_to_folder_name ( config const & config , type type ) Determine the appropriate folder name for a type. Return : The folder name Get the appropriate folder name in the configuration file for the specified type. Not all types have corresponding folder categories.","title":"function type_to_folder_name"},{"location":"reference/namespaces/namespacedoxybook/#function-type_to_index_name","text":"std :: string type_to_index_name ( config const & config , folder_category type ) Determine the appropriate index file name for a folder category. Return : The folder name Get the appropriate index file name in the configuration file for the specified folder category. Not all types have corresponding folder categories.","title":"function type_to_index_name"},{"location":"reference/namespaces/namespacedoxybook/#function-type_to_index_template","text":"std :: string type_to_index_template ( config const & config , folder_category type ) Determine the appropriate index template file name for a folder category. Return : The folder name Get the appropriate template file name in the configuration file for the specified folder category. Not all types have corresponding folder categories.","title":"function type_to_index_template"},{"location":"reference/namespaces/namespacedoxybook/#function-type_to_index_title","text":"std :: string type_to_index_title ( config const & config , folder_category type ) Determine the appropriate index title name for a folder category. Return : The folder name Get the appropriate index title name in the configuration file for the specified folder category. Not all types have corresponding folder categories.","title":"function type_to_index_title"},{"location":"reference/namespaces/namespacedoxybook/#function-to_json","text":"inline void to_json ( nlohmann :: json & j , visibility const & p ) Convert a visibility type to a json string.","title":"function to_json"},{"location":"reference/namespaces/namespacedoxybook/#function-from_json","text":"inline void from_json ( nlohmann :: json const & j , visibility & p ) Convert a json string to a visibility type.","title":"function from_json"},{"location":"reference/namespaces/namespacedoxybook/#function-to_json_1","text":"inline void to_json ( nlohmann :: json & j , folder_category const & p ) Convert a folder category to a json string.","title":"function to_json"},{"location":"reference/namespaces/namespacedoxybook/#function-from_json_1","text":"inline void from_json ( nlohmann :: json const & j , folder_category & p ) Convert a json string to a folder category.","title":"function from_json"},{"location":"reference/namespaces/namespacedoxybook/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"reference/namespaces/namespacedoxybook/#variable-default_templates","text":"std :: unordered_map < std :: string , default_template > default_templates ; A map with all the default templates. Unless template files are provided, these templates are used. Updated on 2022-11-15 at 04:08:09 +0000","title":"variable default_templates"},{"location":"reference/namespaces/namespacedoxybook_1_1path/","text":"doxybook::path Functions Name template <typename... Args> std::string join (Args const &... args) Join string arguments as a path. std::string filename (std::string const & path) Get the filename from a path string. Functions Documentation function join template < typename ... Args > inline std :: string join ( Args const & ... args ) Join string arguments as a path. function filename inline std :: string filename ( std :: string const & path ) Get the filename from a path string. Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook::path"},{"location":"reference/namespaces/namespacedoxybook_1_1path/#doxybookpath","text":"","title":"doxybook::path"},{"location":"reference/namespaces/namespacedoxybook_1_1path/#functions","text":"Name template <typename... Args> std::string join (Args const &... args) Join string arguments as a path. std::string filename (std::string const & path) Get the filename from a path string.","title":"Functions"},{"location":"reference/namespaces/namespacedoxybook_1_1path/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"reference/namespaces/namespacedoxybook_1_1path/#function-join","text":"template < typename ... Args > inline std :: string join ( Args const & ... args ) Join string arguments as a path.","title":"function join"},{"location":"reference/namespaces/namespacedoxybook_1_1path/#function-filename","text":"inline std :: string filename ( std :: string const & path ) Get the filename from a path string. Updated on 2022-11-15 at 04:08:09 +0000","title":"function filename"},{"location":"reference/namespaces/namespacedoxybook_1_1utils/","text":"doxybook::utils Functions Name template <typename... Args> std::string join (Args const &... args) Join string arguments as a path. std::string filename (std::string const & path) Get the filename from a path string. std::string escape (std::string str) Escape a string. std::string title (std::string str) Capitalize string. std::string to_lower (std::string str) Convert string to lowercase. std::string safe_anchor_id (std::string str, bool replace_underscores) Create a safe anchor for a string. std::string namespace_to_package (std::string str) Convert a namespace string to a package string. std::string date (std::string const & format) Get current date as a string. std::string strip_namespace (std::string const & format) Strip namespace from symbol. std::string strip_anchor (std::string const & str) Strip anchors from a string. std::vector< std::string > split (std::string const & str, std::string const & delim) Split string with the specified delimiter. void create_directory (std::string const & path) Create a directory. std::string normalize_language (std::string const & language) Normalize the language name. std::string replace_newline (std::string str) Replace newlines with whitespaces. Functions Documentation function join template < typename ... Args > inline std :: string join ( Args const & ... args ) Join string arguments as a path. function filename inline std :: string filename ( std :: string const & path ) Get the filename from a path string. function escape std :: string escape ( std :: string str ) Escape a string. function title std :: string title ( std :: string str ) Capitalize string. function to_lower std :: string to_lower ( std :: string str ) Convert string to lowercase. function safe_anchor_id std :: string safe_anchor_id ( std :: string str , bool replace_underscores ) Create a safe anchor for a string. Parameters : str string to convert replace_underscores replaces underscores with hyphens Return : converted string function namespace_to_package std :: string namespace_to_package ( std :: string str ) Convert a namespace string to a package string. This replaces all occurences of \"::\" with \".\" function date std :: string date ( std :: string const & format ) Get current date as a string. function strip_namespace std :: string strip_namespace ( std :: string const & format ) Strip namespace from symbol. function strip_anchor std :: string strip_anchor ( std :: string const & str ) Strip anchors from a string. function split std :: vector < std :: string > split ( std :: string const & str , std :: string const & delim ) Split string with the specified delimiter. function create_directory void create_directory ( std :: string const & path ) Create a directory. function normalize_language std :: string normalize_language ( std :: string const & language ) Normalize the language name. function replace_newline std :: string replace_newline ( std :: string str ) Replace newlines with whitespaces. Updated on 2022-11-15 at 04:08:09 +0000","title":"doxybook::utils"},{"location":"reference/namespaces/namespacedoxybook_1_1utils/#doxybookutils","text":"","title":"doxybook::utils"},{"location":"reference/namespaces/namespacedoxybook_1_1utils/#functions","text":"Name template <typename... Args> std::string join (Args const &... args) Join string arguments as a path. std::string filename (std::string const & path) Get the filename from a path string. std::string escape (std::string str) Escape a string. std::string title (std::string str) Capitalize string. std::string to_lower (std::string str) Convert string to lowercase. std::string safe_anchor_id (std::string str, bool replace_underscores) Create a safe anchor for a string. std::string namespace_to_package (std::string str) Convert a namespace string to a package string. std::string date (std::string const & format) Get current date as a string. std::string strip_namespace (std::string const & format) Strip namespace from symbol. std::string strip_anchor (std::string const & str) Strip anchors from a string. std::vector< std::string > split (std::string const & str, std::string const & delim) Split string with the specified delimiter. void create_directory (std::string const & path) Create a directory. std::string normalize_language (std::string const & language) Normalize the language name. std::string replace_newline (std::string str) Replace newlines with whitespaces.","title":"Functions"},{"location":"reference/namespaces/namespacedoxybook_1_1utils/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"reference/namespaces/namespacedoxybook_1_1utils/#function-join","text":"template < typename ... Args > inline std :: string join ( Args const & ... args ) Join string arguments as a path.","title":"function join"},{"location":"reference/namespaces/namespacedoxybook_1_1utils/#function-filename","text":"inline std :: string filename ( std :: string const & path ) Get the filename from a path string.","title":"function filename"},{"location":"reference/namespaces/namespacedoxybook_1_1utils/#function-escape","text":"std :: string escape ( std :: string str ) Escape a string.","title":"function escape"},{"location":"reference/namespaces/namespacedoxybook_1_1utils/#function-title","text":"std :: string title ( std :: string str ) Capitalize string.","title":"function title"},{"location":"reference/namespaces/namespacedoxybook_1_1utils/#function-to_lower","text":"std :: string to_lower ( std :: string str ) Convert string to lowercase.","title":"function to_lower"},{"location":"reference/namespaces/namespacedoxybook_1_1utils/#function-safe_anchor_id","text":"std :: string safe_anchor_id ( std :: string str , bool replace_underscores ) Create a safe anchor for a string. Parameters : str string to convert replace_underscores replaces underscores with hyphens Return : converted string","title":"function safe_anchor_id"},{"location":"reference/namespaces/namespacedoxybook_1_1utils/#function-namespace_to_package","text":"std :: string namespace_to_package ( std :: string str ) Convert a namespace string to a package string. This replaces all occurences of \"::\" with \".\"","title":"function namespace_to_package"},{"location":"reference/namespaces/namespacedoxybook_1_1utils/#function-date","text":"std :: string date ( std :: string const & format ) Get current date as a string.","title":"function date"},{"location":"reference/namespaces/namespacedoxybook_1_1utils/#function-strip_namespace","text":"std :: string strip_namespace ( std :: string const & format ) Strip namespace from symbol.","title":"function strip_namespace"},{"location":"reference/namespaces/namespacedoxybook_1_1utils/#function-strip_anchor","text":"std :: string strip_anchor ( std :: string const & str ) Strip anchors from a string.","title":"function strip_anchor"},{"location":"reference/namespaces/namespacedoxybook_1_1utils/#function-split","text":"std :: vector < std :: string > split ( std :: string const & str , std :: string const & delim ) Split string with the specified delimiter.","title":"function split"},{"location":"reference/namespaces/namespacedoxybook_1_1utils/#function-create_directory","text":"void create_directory ( std :: string const & path ) Create a directory.","title":"function create_directory"},{"location":"reference/namespaces/namespacedoxybook_1_1utils/#function-normalize_language","text":"std :: string normalize_language ( std :: string const & language ) Normalize the language name.","title":"function normalize_language"},{"location":"reference/namespaces/namespacedoxybook_1_1utils/#function-replace_newline","text":"std :: string replace_newline ( std :: string str ) Replace newlines with whitespaces. Updated on 2022-11-15 at 04:08:09 +0000","title":"function replace_newline"},{"location":"reference/pages/","text":"Pages Updated on 2022-11-15 at 04:08:09 +0000","title":"Pages"},{"location":"reference/pages/#pages","text":"Updated on 2022-11-15 at 04:08:09 +0000","title":"Pages"}]}